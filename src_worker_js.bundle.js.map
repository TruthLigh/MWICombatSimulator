{"version":3,"file":"src_worker_js.bundle.js","mappings":";;;;;;;;;;;;;;;;AAA0B;AACkC;AAC5B;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wDAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,6CAAI;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,kCAAkC,gDAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gDAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;;ACxNG;AACkD;AACR;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gEAAwB;AAChE;AACA,0CAA0C,4DAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6CAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,WAAW;;;;;;;;;;;;;;AC1B1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACd4B;AACO;AACQ;AACU;AAChB;AACM;AACF;AACF;AACd;AACgB;AACR;AACU;AACE;AACI;AACJ;AACE;AACJ;AACR;AACnB;AAC2B;AACF;AAC7B;AACA;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,8BAA8B,0DAAU;AACxC,6BAA6B,mDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,KAAK,MAAM,WAAW,OAAO,YAAY;AAChE,wBAAwB,YAAY,KAAK,YAAY;AACrD,yBAAyB,cAAc,IAAI,YAAY;AACvD,4BAA4B,0BAA0B,OAAO,IAAI,UAAU,GAAG,MAAM,eAAe;AACnG;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gEAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,2BAA2B,0CAA0C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAA0C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gEAAgB;AACjC;AACA;AACA,iBAAiB,kEAAkB;AACnC;AACA;AACA,iBAAiB,iEAAiB;AAClC;AACA;AACA,iBAAiB,+DAAe;AAChC;AACA;AACA,iBAAiB,mEAAmB;AACpC;AACA;AACA,iBAAiB,mEAAmB;AACpC;AACA;AACA,iBAAiB,wEAAwB;AACzC;AACA;AACA,iBAAiB,+DAAc;AAC/B;AACA;AACA,iBAAiB,oEAAmB;AACpC;AACA;AACA,iBAAiB,qEAAoB;AACrC;AACA;AACA,iBAAiB,uEAAsB;AACvC;AACA;AACA,iBAAiB,qEAAoB;AACrC;AACA;AACA,iBAAiB,sEAAqB;AACtC;AACA;AACA,iBAAiB,oEAAmB;AACpC;AACA;AACA,iBAAiB,gEAAe;AAChC;AACA;AACA,iBAAiB,oEAAmB;AACpC;AACA;AACA,iBAAiB,mEAAkB;AACnC;AACA;AACA;AACA,iBAAiB,kEAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD,mCAAmC;AACnC;AACA;AACA;AACA;AACA,iCAAiC,+DAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,0CAA0C,gEAAe;AACzD,kCAAkC,gEAAe;AACjD;AACA;AACA;AACA,0CAA0C,oEAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAe,uCAAuC,oCAAoC;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,qEAAoB;AACjH;AACA;AACA,uEAAuE,qEAAoB;AAC3F;AACA,+CAA+C,qEAAoB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,oEAAmB;AAC/G,uEAAuE,oEAAmB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oEAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,sEAAqB;AACnH;AACA;AACA;AACA,uEAAuE,sEAAqB;AAC5F,gDAAgD,sEAAqB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,+DAAe;AAC7D;AACA,wCAAwC,iEAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G,kEAAkB;AAC9H;AACA,iDAAiD,kEAAkB;AACnE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW,GAAG,IAAI;AACxD,yBAAyB;AACzB;AACA,6DAA6D,gCAAgC,gBAAgB,YAAY;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+DAAe;AACjE,kDAAkD,oEAAmB;AACrE,kDAAkD,mEAAmB;AACrE,kDAAkD,mEAAmB;AACrE,kDAAkD,+DAAc;AAChE,kDAAkD,gEAAe;AACjE,kDAAkD,oEAAmB;AACrE,kDAAkD,qEAAoB;AACtE,kDAAkD,uEAAsB;AACxE,kDAAkD,mEAAkB;AACpE;AACA;AACA,2CAA2C,gEAAgB;AAC3D;AACA,cAAc;AACd,kDAAkD,+DAAe;AACjE,kDAAkD,oEAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,oEAAmB,uBAAuB,+DAAe;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAe;AACpC;AACA;AACA,UAAU;AACV,qBAAqB,wDAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,oEAAmB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+DAAe;AACrD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mEAAkB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mEAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mEAAmB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mEAAkB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,kCAAkC,gEAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,qCAAqC,kEAAkB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mEAAkB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,0CAA0C,mEAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,wEAAwB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mCAAmC,iDAAO;AAC1C;AACA;AACA;AACA,mCAAmC,iDAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,uDAAuD,wEAAwB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,wEAAwB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wDAAe,+CAA+C,oCAAoC;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wDAAe,gDAAgD,sHAAsH;AACxN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,wEAAwB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mEAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,+DAAe,uBAAuB,oEAAmB,uBAAuB,oEAAmB;AAC/K,kDAAkD,oEAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,qEAAoB;AAC/F,+EAA+E,+DAAe;AAC9F;AACA;AACA;AACA,mDAAmD,qEAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,uEAAsB;AACjG,+EAA+E,oEAAmB;AAClG;AACA;AACA;AACA,qDAAqD,uEAAsB;AAC3E;AACA;AACA;AACA;AACA;AACA,iGAAiG,qEAAoB;AACrH;AACA;AACA,2EAA2E,qEAAoB;AAC/F;AACA,mDAAmD,qEAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,oEAAmB;AACnH,2EAA2E,oEAAmB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,oEAAmB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,sEAAqB;AACvH;AACA;AACA;AACA,2EAA2E,sEAAqB;AAChG,oDAAoD,sEAAqB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA,mCAAmC,wDAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wDAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wDAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA,mEAAmE,kEAAkB;AACrF;AACA;AACA;AACA,+BAA+B,wDAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAe;AACrC;AACA;AACA;AACA;AACA;AACA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;ACpqD/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wDAAwD;AACtF,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,UAAU,EAAC;;;;;;;;;;;;;;;AC3jB1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;;;;ACrWL;AAC4B;AACtB;;AAEhC;AACA;AACA;;AAEA,6BAA6B,qDAAa;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,6CAAI;AACnC;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,kCAAkC,gDAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qDAAqD,gDAAO;AAC5D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iEAAe,UAAU,EAAC;;;;;;;;;;;;;;;ACtF1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;;;ACXiC;AACmD;;AAEzG;AACA;AACA;AACA,uBAAuB,qDAAa;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB,iFAAoC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;AC/Ce;;AAExC,kCAAkC,oDAAW;AAC7C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iEAAe,mBAAmB;;;;;;;;;;;;;;;ACbM;;AAExC,8BAA8B,oDAAW;AACzC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;;ACZS;;AAExC,iCAAiC,oDAAW;AAC5C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iEAAe,kBAAkB;;;;;;;;;;;;;;;ACZO;;AAExC,mCAAmC,oDAAW;AAC9C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iEAAe,oBAAoB;;;;;;;;;;;;;;;ACZK;;AAExC,uCAAuC,oDAAW;AAClD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iEAAe,wBAAwB,EAAC;;;;;;;;;;;;;;;ACZxC;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,WAAW,EAAC;;;;;;;;;;;;;;;;ACPa;;AAExC,+BAA+B,oDAAW;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA,iEAAe,gBAAgB,EAAC;;;;;;;;;;;;;;;;ACVQ;;AAExC,kCAAkC,oDAAW;AAC7C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,mBAAmB,EAAC;;;;;;;;;;;;;;;;ACfK;;AAExC,iCAAiC,oDAAW;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA,iEAAe,kBAAkB,EAAC;;;;;;;;;;;;;;;;ACVM;;AAExC,mCAAmC,oDAAW;AAC9C;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,iEAAe,oBAAoB;;;;;;;;;;;;;;;ACfK;;AAExC,kCAAkC,oDAAW;AAC7C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,mBAAmB,EAAC;;;;;;;;;;;;;;;;AClBK;;AAExC,gCAAgC,oDAAW;AAC3C;;AAEA;AACA;AACA;AACA;;AAEA,iEAAe,iBAAiB,EAAC;;;;;;;;;;;;;;;;ACVO;;AAExC,8BAA8B,oDAAW;AACzC;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;;ACbJ;;AAE3B;AACA;AACA,2BAA2B,+CAAI;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,+CAAI;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,UAAU,EAAC;;;;;;;;;;;;;;;;AChEc;;AAExC,kCAAkC,oDAAW;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,mBAAmB;;;;;;;;;;;;;;;ACbM;;AAExC,iCAAiC,oDAAW;AAC5C;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,kBAAkB,EAAC;;;;;;;;;;;;;;;;ACXM;;AAExC,6BAA6B,oDAAW;AACxC;;AAEA;AACA;AACA;AACA;;AAEA,iEAAe,cAAc,EAAC;;;;;;;;;;;;;;;;ACVU;;AAExC,qCAAqC,oDAAW;AAChD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iEAAe,sBAAsB;;;;;;;;;;;;;;;ACZG;;AAExC,kCAAkC,oDAAW;AAC7C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iEAAe,mBAAmB;;;;;;;;;;;;;;;ACZM;;AAExC,oCAAoC,oDAAW;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,qBAAqB;;;;;;;;;;;;;;;;AChBV;AACsC;;AAEhE;AACA;AACA;AACA;;AAEA,4BAA4B,0DAAkB;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,6CAAI;AACnC;AACA;AACA;AACA;AACA;AACA,+BAA+B,6CAAI;AACnC;AACA;AACA;AACA;AACA;;AAEA,iEAAe,SAAS;;;;;;;;;;;;;;;;;;AC7BQ;AACM;AACkC;AAC5C;AAC5B;AACA,sBAAsB,mDAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8DAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA;AACA,oCAAoC,gDAAO;AAC3C;AACA;AACA,wBAAwB,kCAAkC;AAC1D,oCAAoC,8CAAK;AACzC;AACA,wBAAwB,sCAAsC;AAC9D;AACA;AACA;AACA,wCAAwC,8CAAK;AAC7C;AACA;AACA;AACA;AACA,0BAA0B,8DAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;;;;;ACzJS;AACM;AACA;AACF;AACA;AACI;AACxC;AACA,qBAAqB,mDAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kDAAS;AACrD;AACA;AACA,qDAAqD,mDAAU;AAC/D,2DAA2D,mDAAU;AACrE,qEAAqE,gDAAO;AAC5E;AACA;AACA,2CAA2C,kDAAS;AACpD;AACA,SAAS;AACT;AACA,kCAAkC,oDAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;ACvL6C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,2CAA2C,uEAAuE;AAClH;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4DAAoB;AAChD;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;AClSmE;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAgC;AAC5C;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;AClLmC;AAC1B;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gDAAO;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAyD;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,wEAAwE;AACtH;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gDAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gDAAO;AAC/D,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc;AACd,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iCAAiC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,wEAAwE;AAC1H;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,gDAAO;AAC3D;AACA;AACA;AACA;AACA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;ACpH4C;AAClB;AACJ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAAI;AAC/B,4BAA4B,wBAAwB;AACpD,oCAAoC,+DAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wEAAe,kBAAkB,yBAAyB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,mCAAmC,iDAAiD;AACpF,cAAc;AACd;AACA,mCAAmC,oCAAoC;AACvE;AACA;AACA;AACA","sources":["webpack://mwicombatsimulator/./src/combatsimulator/ability.js","webpack://mwicombatsimulator/./src/combatsimulator/achievement.js","webpack://mwicombatsimulator/./src/combatsimulator/buff.js","webpack://mwicombatsimulator/./src/combatsimulator/combatSimulator.js","webpack://mwicombatsimulator/./src/combatsimulator/combatUnit.js","webpack://mwicombatsimulator/./src/combatsimulator/combatUtilities.js","webpack://mwicombatsimulator/./src/combatsimulator/consumable.js","webpack://mwicombatsimulator/./src/combatsimulator/drops.js","webpack://mwicombatsimulator/./src/combatsimulator/equipment.js","webpack://mwicombatsimulator/./src/combatsimulator/events/abilityCastEndEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/autoAttackEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/awaitCooldownEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/blindExpirationEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/checkBuffExpirationEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/combatEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/combatStartEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/consumableTickEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/cooldownReadyEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/curseExpirationEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/damageOverTimeEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/enemyRespawnEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/enrageTickEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/eventQueue.js","webpack://mwicombatsimulator/./src/combatsimulator/events/furyExpirationEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/playerRespawnEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/regenTickEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/silenceExpirationEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/stunExpirationEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/weakenExpirationEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/houseRoom.js","webpack://mwicombatsimulator/./src/combatsimulator/monster.js","webpack://mwicombatsimulator/./src/combatsimulator/player.js","webpack://mwicombatsimulator/./src/combatsimulator/simResult.js","webpack://mwicombatsimulator/./src/combatsimulator/trigger.js","webpack://mwicombatsimulator/./src/combatsimulator/zone.js","webpack://mwicombatsimulator/./src/worker.js"],"sourcesContent":["import Buff from \"./buff\";\r\nimport abilityDetailMap from \"./data/abilityDetailMap.json\";\r\nimport Trigger from \"./trigger\";\r\n\r\nconst abilityFromCombatStat = {\r\n    \"blaze\":\r\n    {\r\n        \"hrid\": \"/abilities/blaze\",\r\n        \"name\": \"Blaze\",\r\n        \"description\": \"\",\r\n        \"isSpecialAbility\": false,\r\n        \"manaCost\": 0,\r\n        \"cooldownDuration\": 0,\r\n        \"castDuration\": 0,\r\n        \"abilityEffects\": [\r\n            {\r\n                \"targetType\": \"allEnemies\",\r\n                \"effectType\": \"/ability_effect_types/damage\",\r\n                \"combatStyleHrid\": \"/combat_styles/magic\",\r\n                \"damageType\": \"/damage_types/fire\",\r\n                \"baseDamageFlat\": 0,\r\n                \"baseDamageFlatLevelBonus\": 0.0,\r\n                \"baseDamageRatio\": 0.3,\r\n                \"baseDamageRatioLevelBonus\": 0,\r\n                \"bonusAccuracyRatio\": 0,\r\n                \"bonusAccuracyRatioLevelBonus\": 0,\r\n                \"damageOverTimeRatio\": 0,\r\n                \"damageOverTimeDuration\": 0,\r\n                \"armorDamageRatio\": 0,\r\n                \"armorDamageRatioLevelBonus\": 0,\r\n                \"hpDrainRatio\": 0,\r\n                \"pierceChance\": 0,\r\n                \"blindChance\": 0,\r\n                \"blindDuration\": 0,\r\n                \"silenceChance\": 0,\r\n                \"silenceDuration\": 0,\r\n                \"stunChance\": 0,\r\n                \"stunDuration\": 0,\r\n                \"spendHpRatio\": 0,\r\n                \"buffs\": null\r\n            }\r\n        ],\r\n        \"defaultCombatTriggers\": [\r\n            {\r\n                \"dependencyHrid\": \"/combat_trigger_dependencies/all_enemies\",\r\n                \"conditionHrid\": \"/combat_trigger_conditions/number_of_active_units\",\r\n                \"comparatorHrid\": \"/combat_trigger_comparators/greater_than_equal\",\r\n                \"value\": 1\r\n            },\r\n            {\r\n                \"dependencyHrid\": \"/combat_trigger_dependencies/all_enemies\",\r\n                \"conditionHrid\": \"/combat_trigger_conditions/current_hp\",\r\n                \"comparatorHrid\": \"/combat_trigger_comparators/greater_than_equal\",\r\n                \"value\": 1\r\n            }\r\n        ],\r\n    },\r\n    \"bloom\":\r\n    {\r\n        \"hrid\": \"/abilities/bloom\",\r\n        \"name\": \"Bloom\",\r\n        \"description\": \"\",\r\n        \"isSpecialAbility\": false,\r\n        \"manaCost\": 0,\r\n        \"cooldownDuration\": 0,\r\n        \"castDuration\": 0,\r\n        \"abilityEffects\": [\r\n            {\r\n                \"targetType\": \"lowestHpAlly\",\r\n                \"effectType\": \"/ability_effect_types/heal\",\r\n                \"combatStyleHrid\": \"/combat_styles/magic\",\r\n                \"damageType\": \"\",\r\n                \"baseDamageFlat\": 10,\r\n                \"baseDamageFlatLevelBonus\": 0,\r\n                \"baseDamageRatio\": 0.15,\r\n                \"baseDamageRatioLevelBonus\": 0,\r\n                \"bonusAccuracyRatio\": 0,\r\n                \"bonusAccuracyRatioLevelBonus\": 0,\r\n                \"damageOverTimeRatio\": 0,\r\n                \"damageOverTimeDuration\": 0,\r\n                \"armorDamageRatio\": 0,\r\n                \"armorDamageRatioLevelBonus\": 0,\r\n                \"hpDrainRatio\": 0,\r\n                \"pierceChance\": 0,\r\n                \"blindChance\": 0,\r\n                \"blindDuration\": 0,\r\n                \"silenceChance\": 0,\r\n                \"silenceDuration\": 0,\r\n                \"stunChance\": 0,\r\n                \"stunDuration\": 0,\r\n                \"spendHpRatio\": 0,\r\n                \"buffs\": null\r\n            }\r\n        ],\r\n        \"defaultCombatTriggers\": [\r\n            {\r\n                \"dependencyHrid\": \"/combat_trigger_dependencies/all_allies\",\r\n                \"conditionHrid\": \"/combat_trigger_conditions/lowest_hp_percentage\",\r\n                \"comparatorHrid\": \"/combat_trigger_comparators/less_than_equal\",\r\n                \"value\": 100\r\n            }\r\n        ],\r\n    }\r\n}\r\n\r\nclass Ability {\r\n    constructor(hrid, level = 1, triggers = null) {\r\n        this.hrid = hrid;\r\n        this.level = level;\r\n\r\n        let gameAbility = abilityDetailMap[hrid];\r\n        if (!gameAbility) {\r\n            gameAbility = abilityFromCombatStat[hrid];\r\n        }\r\n        if (!gameAbility) {\r\n            throw new Error(\"No ability found for hrid: \" + this.hrid);\r\n        }\r\n\r\n        this.manaCost = gameAbility.manaCost;\r\n        this.cooldownDuration = gameAbility.cooldownDuration;\r\n        this.castDuration = gameAbility.castDuration;\r\n        this.isSpecialAbility = gameAbility.isSpecialAbility;\r\n\r\n        this.abilityEffects = [];\r\n\r\n        for (const effect of gameAbility.abilityEffects) {\r\n            let abilityEffect = {\r\n                targetType: effect.targetType,\r\n                effectType: effect.effectType,\r\n                combatStyleHrid: effect.combatStyleHrid,\r\n                damageType: effect.damageType,\r\n                damageFlat: effect.baseDamageFlat + (this.level - 1) * effect.baseDamageFlatLevelBonus,\r\n                damageRatio: effect.baseDamageRatio + (this.level - 1) * effect.baseDamageRatioLevelBonus,\r\n                bonusAccuracyRatio: effect.bonusAccuracyRatio + (this.level - 1) * effect.bonusAccuracyRatioLevelBonus,\r\n                damageOverTimeRatio: effect.damageOverTimeRatio,\r\n                damageOverTimeDuration: effect.damageOverTimeDuration,\r\n                armorDamageRatio: effect.armorDamageRatio + (this.level - 1) * effect.armorDamageRatioLevelBonus,\r\n                hpDrainRatio: effect.hpDrainRatio,\r\n                pierceChance: effect.pierceChance,\r\n                blindChance: effect.blindChance,\r\n                blindDuration: effect.blindDuration,\r\n                silenceChance: effect.silenceChance,\r\n                silenceDuration: effect.silenceDuration,\r\n                stunChance: effect.stunChance,\r\n                stunDuration: effect.stunDuration,\r\n                spendHpRatio: effect.spendHpRatio,\r\n                buffs: null,\r\n            };\r\n            if (effect.buffs) {\r\n                abilityEffect.buffs = [];\r\n                for (const buff of effect.buffs) {\r\n                    abilityEffect.buffs.push(new Buff(buff, this.level));\r\n                }\r\n            }\r\n            this.abilityEffects.push(abilityEffect);\r\n        }\r\n\r\n        if (triggers) {\r\n            this.triggers = triggers;\r\n        } else {\r\n            this.triggers = [];\r\n            for (const defaultTrigger of gameAbility.defaultCombatTriggers) {\r\n                let trigger = new Trigger(\r\n                    defaultTrigger.dependencyHrid,\r\n                    defaultTrigger.conditionHrid,\r\n                    defaultTrigger.comparatorHrid,\r\n                    defaultTrigger.value\r\n                );\r\n                this.triggers.push(trigger);\r\n            }\r\n        }\r\n\r\n        this.lastUsed = Number.MIN_SAFE_INTEGER;\r\n    }\r\n\r\n    static createFromDTO(dto) {\r\n        let triggers = dto.triggers.map((trigger) => Trigger.createFromDTO(trigger));\r\n        let ability = new Ability(dto.hrid, dto.level, triggers);\r\n\r\n        return ability;\r\n    }\r\n\r\n    shouldTrigger(currentTime, source, target, friendlies, enemies) {\r\n        if (source.isStunned) {\r\n            return false;\r\n        }\r\n\r\n        if (source.isSilenced) {\r\n            return false;\r\n        }\r\n\r\n        let haste = source.combatDetails.combatStats.abilityHaste;\r\n        let cooldownDuration = this.cooldownDuration;\r\n        if (haste > 0) {\r\n            cooldownDuration = cooldownDuration * 100 / (100 + haste);\r\n        }\r\n\r\n        if (this.lastUsed + cooldownDuration > currentTime) {\r\n            return false;\r\n        }\r\n\r\n        if (this.triggers.length == 0) {\r\n            return true;\r\n        }\r\n\r\n        let shouldTrigger = true;\r\n        for (const trigger of this.triggers) {\r\n            if (!trigger.isActive(source, target, friendlies, enemies, currentTime)) {\r\n                shouldTrigger = false;\r\n            }\r\n        }\r\n\r\n        return shouldTrigger;\r\n    }\r\n}\r\n\r\nexport default Ability;\r\n","import Buff from \"./buff\";\r\nimport achievementTierDetailMap from \"./data/achievementTierDetailMap.json\";\r\nimport achievementDetailMap from \"./data/achievementDetailMap.json\";\r\n\r\nclass Achievement {\r\n    constructor(achievements) {\r\n        this.achievements = achievements;\r\n        this.buffs = [];\r\n\r\n        for(const tier of Object.values(achievementTierDetailMap)) {\r\n            let isGetAll = true;\r\n            let detailMap = Object.values(achievementDetailMap).filter((detail) => detail.tierHrid == tier.hrid)\r\n            for(const achievement of Object.values(detailMap)) {\r\n                if(!this.achievements[achievement.hrid] || this.achievements[achievement.hrid] == false) {\r\n                    isGetAll = false;\r\n                    break;\r\n                }\r\n            }\r\n            if(isGetAll) {\r\n                let buff = new Buff(tier.buff);\r\n                this.buffs.push(buff);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default Achievement;","class Buff {\n    startTime;\n\n    constructor(buff, level = 1) {\n        this.uniqueHrid = buff.uniqueHrid;\n        this.typeHrid = buff.typeHrid;\n        this.ratioBoost = buff.ratioBoost + (level - 1) * buff.ratioBoostLevelBonus;\n        this.flatBoost = buff.flatBoost + (level - 1) * buff.flatBoostLevelBonus;\n        this.duration = buff.duration;\n        this.multiplierForSkillHrid = buff.multiplierForSkillHrid ?? \"\";\n        this.multiplierPerSkillLevel = buff.multiplierPerSkillLevel ?? 0;\n    }\n}\n\nexport default Buff;\n","import CombatUtilities from \"./combatUtilities\";\r\nimport AutoAttackEvent from \"./events/autoAttackEvent\";\r\nimport DamageOverTimeEvent from \"./events/damageOverTimeEvent\";\r\nimport CheckBuffExpirationEvent from \"./events/checkBuffExpirationEvent\";\r\nimport CombatStartEvent from \"./events/combatStartEvent\";\r\nimport ConsumableTickEvent from \"./events/consumableTickEvent\";\r\nimport CooldownReadyEvent from \"./events/cooldownReadyEvent\";\r\nimport EnemyRespawnEvent from \"./events/enemyRespawnEvent\";\r\nimport EventQueue from \"./events/eventQueue\";\r\nimport PlayerRespawnEvent from \"./events/playerRespawnEvent\";\r\nimport RegenTickEvent from \"./events/regenTickEvent\";\r\nimport StunExpirationEvent from \"./events/stunExpirationEvent\";\r\nimport BlindExpirationEvent from \"./events/blindExpirationEvent\";\r\nimport SilenceExpirationEvent from \"./events/silenceExpirationEvent\";\r\nimport CurseExpirationEvent from \"./events/curseExpirationEvent\";\r\nimport WeakenExpirationEvent from \"./events/weakenExpirationEvent\";\r\nimport FuryExpirationEvent from \"./events/furyExpirationEvent\";\r\nimport EnrageTickEvent from \"./events/enrageTickEvent\";\r\nimport SimResult from \"./simResult\";\r\nimport AbilityCastEndEvent from \"./events/abilityCastEndEvent\";\r\nimport AwaitCooldownEvent from \"./events/awaitCooldownEvent\";\r\nimport Monster from \"./monster\";\r\nimport Ability from \"./ability\";\r\n\r\nconst ONE_SECOND = 1e9;\r\nconst HOT_TICK_INTERVAL = 5 * ONE_SECOND;\r\nconst DOT_TICK_INTERVAL = 3 * ONE_SECOND;\r\nconst REGEN_TICK_INTERVAL = 10 * ONE_SECOND;\r\nconst ENEMY_RESPAWN_INTERVAL = 3 * ONE_SECOND;\r\nconst PLAYER_RESPAWN_INTERVAL = 150 * ONE_SECOND;\r\nconst RESTART_INTERVAL = 3 * ONE_SECOND;\r\nconst ENRAGE_TICK_INTERVAL = 60 * ONE_SECOND;\r\n\r\nclass CombatSimulator extends EventTarget {\r\n    constructor(players, zone, options = {}) {\r\n        super();\r\n        this.players = players;\r\n        this.zone = zone;\r\n        this.eventQueue = new EventQueue();\r\n        this.simResult = new SimResult(zone, players.length);\r\n        this.allPlayersDead = false;\r\n        this.enableHpMpVisualization = options.enableHpMpVisualization || false;\r\n\r\n        this.wipeLogs = {\r\n            buffer: new Array(200),\r\n            index: 0,\r\n            count: 0,\r\n            maxSize: 200\r\n        };\r\n    }\r\n\r\n        addToWipeLogs(logEntry) {\r\n        const { buffer, maxSize } = this.wipeLogs;\r\n\r\n        buffer[this.wipeLogs.index] = logEntry;\r\n        this.wipeLogs.index = (this.wipeLogs.index + 1) % maxSize;\r\n        this.wipeLogs.count = Math.min(this.wipeLogs.count + 1, maxSize);\r\n    }\r\n\r\n    logAndResetWipeLogs() {\r\n        const logs = this.getOrderedWipeLogs();\r\n        \r\n        // console.log(\"===== 团灭日志 =====\");\r\n        // console.log(`最后 ${logs.length} 条战斗日志：`);\r\n        \r\n        logs.forEach(log => {\r\n            if (log.error) {\r\n                console.log(log.error);\r\n                return;\r\n            }\r\n            \r\n            const time = (log.time / 1e9).toFixed(2);\r\n            // console.log(\r\n            //     `[${time}s] [${log.source}] 用 [${log.ability}] ` +\r\n            //     `对 ${log.target} 造成 ${log.damage} 伤害，` +\r\n            //     `HP ${log.beforeHp} → ${log.afterHp}。` +\r\n            //     `队伍生命值：${log.playersHp.map(p => `${p.hrid}: ${p.current}/${p.max}`).join(\" | \")}`\r\n            // );\r\n        });\r\n\r\n        this.wipeLogs.index = 0;\r\n        this.wipeLogs.count = 0;\r\n        // console.log(\"===== 团灭日志结束 =====\");\r\n    }\r\n    \r\n    buildCombatLog(source, ability, target, damageDone) {\r\n        try {\r\n            const sourceHrid = source?.hrid || \"UNKNOWN_SOURCE\";\r\n            const targetHrid = target?.hrid || \"UNKNOWN_TARGET\";\r\n            \r\n            const afterHp = target?.combatDetails?.currentHitpoints || 0;\r\n            const beforeHp = Math.max(0, afterHp + damageDone);\r\n\r\n            const playersHp = this.players.map(p => ({\r\n                hrid: p.hrid || \"UNKNOWN_PLAYER\",\r\n                current: p.combatDetails?.currentHitpoints ?? 0,\r\n                max: p.combatDetails?.maxHitpoints ?? 0\r\n            }));\r\n            \r\n            return {\r\n                time: this.simulationTime,\r\n                wave: (this.zone.encountersKilled - 1),\r\n                source: sourceHrid,\r\n                ability: ability,\r\n                target: targetHrid,\r\n                damage: damageDone,\r\n                beforeHp: beforeHp,\r\n                afterHp: afterHp,\r\n                playersHp: playersHp,\r\n                // enemiesHp: enemiesHp,\r\n                isCrit: false,\r\n            };\r\n        } catch (e) {\r\n            return {\r\n                error: `[日志生成错误] ${e.message}`\r\n            };\r\n        }\r\n    }\r\n\r\n    generateCombatLog(source, ability, target, attackResult) {\r\n        try {\r\n            const sourceHrid = source?.hrid || \"UNKNOWN_SOURCE\";\r\n            const targetHrid = target?.hrid || \"UNKNOWN_TARGET\";\r\n            const damage = attackResult?.damageDone || 0;\r\n            \r\n            const afterHp = target?.combatDetails?.currentHitpoints || 0;\r\n            const beforeHp = Math.max(0, afterHp + damage);\r\n\r\n            const playersHp = this.players.map(p => ({\r\n                hrid: p.hrid || \"UNKNOWN_PLAYER\",\r\n                current: p.combatDetails?.currentHitpoints ?? 0,\r\n                max: p.combatDetails?.maxHitpoints ?? 0\r\n            }));\r\n            \r\n            return {\r\n                time: this.simulationTime,\r\n                wave: (this.zone.encountersKilled - 1),\r\n                source: sourceHrid,\r\n                ability: ability,\r\n                target: targetHrid,\r\n                damage: damage,\r\n                beforeHp: beforeHp,\r\n                afterHp: afterHp,\r\n                playersHp: playersHp,\r\n                // enemiesHp: enemiesHp,\r\n                isCrit: attackResult?.isCrit || false,\r\n            };\r\n        } catch (e) {\r\n            return {\r\n                error: `[日志生成错误] ${e.message}`\r\n            };\r\n        }\r\n    }\r\n    \r\n    getOrderedWipeLogs() {\r\n        const { buffer, maxSize, count } = this.wipeLogs;\r\n        const logs = [];\r\n        \r\n        for (let i = 0; i < count; i++) {\r\n            const idx = (this.wipeLogs.index - count + maxSize + i) % maxSize;\r\n            logs.push(buffer[idx]);\r\n        }\r\n        \r\n        return logs;\r\n    }\r\n\r\n    saveWipeLogsToSimResult(wave) {\r\n        const logs = this.getOrderedWipeLogs();\r\n        this.simResult.addWipeEvent(logs, this.simulationTime, wave);\r\n    }\r\n\r\n    async simulate(simulationTimeLimit) {\r\n        this.reset();\r\n\r\n        let ticks = 0;\r\n\r\n        let combatStartEvent = new CombatStartEvent(0);\r\n        this.eventQueue.addEvent(combatStartEvent);\r\n\r\n        while (this.simulationTime < simulationTimeLimit) {\r\n            let nextEvent = this.eventQueue.getNextEvent();\r\n            await this.processEvent(nextEvent);\r\n\r\n            ticks++;\r\n            if (ticks == 1000) {\r\n                ticks = 0;\r\n                // 收集HP/MP时序数据\r\n                if (this.enableHpMpVisualization) {\r\n                    this.simResult.addTimeSeriesSnapshot(this.simulationTime, this.players);\r\n                }\r\n                let progressEvent = new CustomEvent(\"progress\", {\r\n                    detail: {\r\n                        zone: this.zone.hrid,\r\n                        difficultyTier: this.zone.difficultyTier,\r\n                        progress: Math.min(this.simulationTime / simulationTimeLimit, 1),\r\n                        timeSeriesData: this.enableHpMpVisualization ? this.simResult.timeSeriesData : null\r\n                    },\r\n                });\r\n                this.dispatchEvent(progressEvent);\r\n            }\r\n        }\r\n\r\n        // for (let i = 0; i < this.simResult.timeSpentAlive.length; i++) {\r\n        //     if (this.simResult.timeSpentAlive[i].alive == true) {\r\n        //         this.simResult.updateTimeSpentAlive(this.simResult.timeSpentAlive[i].name, false, simulationTimeLimit);\r\n        //     }\r\n        // }\r\n\r\n        this.simResult.isDungeon = this.zone.isDungeon;\r\n        if (this.simResult.isDungeon) {\r\n            console.log(\"Timeout now at wave #\" + (this.zone.encountersKilled - 1));\r\n\r\n            this.simResult.dungeonsCompleted = this.zone.dungeonsCompleted;\r\n            this.simResult.dungeonsFailed = this.zone.dungeonsFailed;\r\n            if (this.simResult.dungeonsCompleted < 1) {\r\n                this.simResult.maxWaveReached = 0;\r\n                for (let i = 0; i <= this.zone.dungeonSpawnInfo.maxWaves; i++) {\r\n                    let waveName = \"#\" + i.toString();\r\n                    const idx = this.simResult.timeSpentAlive.findIndex(e => e.name === waveName);\r\n                    if (idx == -1 || this.simResult.timeSpentAlive[idx].count == 0) {\r\n                        break;\r\n                    }\r\n                    this.simResult.maxWaveReached = i;\r\n                }\r\n            } else {\r\n                this.simResult.maxWaveReached = this.zone.dungeonSpawnInfo.maxWaves;\r\n            }\r\n        }\r\n        this.simResult.simulatedTime = this.simulationTime;\r\n        \r\n        for (let i = 0; i < this.players.length; i++) {\r\n            this.simResult.setDropRateMultipliers(this.players[i]);\r\n            this.simResult.setManaUsed(this.players[i]);\r\n        }\r\n\r\n        if (this.zone.isDungeon) {\r\n            Object.entries(this.zone.dungeonSpawnInfo.fixedSpawnsMap).forEach(([wave, monsters]) => {\r\n                let waveName = \"#\" + wave.toString();\r\n                monsters.forEach(monster => {\r\n                    waveName += ',' + monster.combatMonsterHrid;\r\n                });\r\n                this.simResult.bossSpawns.push(waveName);\r\n            });\r\n\r\n        }\r\n        if (this.zone.monsterSpawnInfo.bossSpawns) {\r\n            for (const boss of this.zone.monsterSpawnInfo.bossSpawns) {\r\n                this.simResult.bossSpawns.push(boss.combatMonsterHrid);\r\n            }\r\n        }\r\n\r\n        return this.simResult;\r\n    }\r\n\r\n    reset() {\r\n        this.tempDungeonCount = 0;\r\n        this.simulationTime = 0;\r\n        this.eventQueue.clear();\r\n        this.simResult = new SimResult(this.zone, this.players.length);\r\n    }\r\n\r\n    async processEvent(event) {\r\n        this.simulationTime = event.time;\r\n\r\n        // console.log(this.simulationTime / 1e9, event.type, event);\r\n\r\n        switch (event.type) {\r\n            case CombatStartEvent.type:\r\n                this.processCombatStartEvent(event);\r\n                break;\r\n            case PlayerRespawnEvent.type:\r\n                this.processPlayerRespawnEvent(event);\r\n                break;\r\n            case EnemyRespawnEvent.type:\r\n                this.processEnemyRespawnEvent(event);\r\n                break;\r\n            case AutoAttackEvent.type:\r\n                this.processAutoAttackEvent(event);\r\n                break;\r\n            case ConsumableTickEvent.type:\r\n                this.processConsumableTickEvent(event);\r\n                break;\r\n            case DamageOverTimeEvent.type:\r\n                this.processDamageOverTimeTickEvent(event);\r\n                break;\r\n            case CheckBuffExpirationEvent.type:\r\n                this.processCheckBuffExpirationEvent(event);\r\n                break;\r\n            case RegenTickEvent.type:\r\n                this.processRegenTickEvent(event);\r\n                break;\r\n            case StunExpirationEvent.type:\r\n                this.processStunExpirationEvent(event);\r\n                break;\r\n            case BlindExpirationEvent.type:\r\n                this.processBlindExpirationEvent(event);\r\n                break;\r\n            case SilenceExpirationEvent.type:\r\n                this.processSilenceExpirationEvent(event);\r\n                break;\r\n            case CurseExpirationEvent.type:\r\n                this.processCurseExpirationEvent(event);\r\n                break;\r\n            case WeakenExpirationEvent.type:\r\n                this.processWeakenExpirationEvent(event);\r\n                break;\r\n            case FuryExpirationEvent.type:\r\n                this.processFuryExpirationEvent(event);\r\n                break;\r\n            case EnrageTickEvent.type:\r\n                this.processEnrageTickEvent(event);\r\n                break;\r\n            case AbilityCastEndEvent.type:\r\n                this.tryUseAbility(event.source, event.ability);\r\n                break;\r\n            case AwaitCooldownEvent.type:\r\n                // console.log(\"Await CD \" + (this.simulationTime / 1000000000));\r\n                this.addNextAttackEvent(event.source);\r\n                break;\r\n            case CooldownReadyEvent.type:\r\n                // Only used to check triggers\r\n                break;\r\n        }\r\n\r\n        this.checkTriggers();\r\n    }\r\n\r\n    processCombatStartEvent(event) {\r\n        // console.log(\"Combat Start \" + (this.simulationTime / 1000000000));\r\n        for (let i = 0; i < this.players.length; i++) {\r\n            if (event.time == 0) { // First combat start event\r\n                this.players[i].generatePermanentBuffs();\r\n            }\r\n            this.players[i].reset(this.simulationTime);\r\n        }\r\n        let regenTickEvent = new RegenTickEvent(this.simulationTime + REGEN_TICK_INTERVAL);\r\n        this.eventQueue.addEvent(regenTickEvent);\r\n\r\n        this.startNewEncounter();\r\n    }\r\n\r\n    processPlayerRespawnEvent(event) {\r\n        // console.log(\"Player \" + event.hrid + \" respawn at \" + + (this.simulationTime / 1000000000));\r\n        let respawningPlayer = this.players.find(player => player.hrid === event.hrid);\r\n        respawningPlayer.combatDetails.currentHitpoints = respawningPlayer.combatDetails.maxHitpoints;\r\n        respawningPlayer.combatDetails.currentManapoints = respawningPlayer.combatDetails.maxManapoints;\r\n        respawningPlayer.clearBuffs();\r\n        respawningPlayer.clearCCs();\r\n        if (this.allPlayersDead) {\r\n            this.allPlayersDead = false;\r\n            this.startAttacks();\r\n        } else {\r\n            this.addNextAttackEvent(respawningPlayer);\r\n        }\r\n    }\r\n\r\n    processEnemyRespawnEvent(event) {\r\n        this.startNewEncounter();\r\n    }\r\n\r\n    startNewEncounter() {\r\n        if (this.allPlayersDead) {\r\n            this.allPlayersDead = false;\r\n            this.zone.failWave();\r\n        }\r\n\r\n        if (!this.zone.isDungeon) {\r\n            this.enemies = this.zone.getRandomEncounter();\r\n        } else {\r\n            this.enemies = this.zone.getNextWave();\r\n            this.simResult.updateTimeSpentAlive(\"#\" + (this.zone.encountersKilled - 1).toString(), true, this.simulationTime);\r\n            let currentDungeonCount = this.zone.dungeonsCompleted;\r\n            // console.log('wave at #' + (this.zone.encountersKilled - 1) +' completed:' + this.zone.dungeonsCompleted + ' failed:'+ this.zone.dungeonsFailed + ' temp:'+ this.tempDungeonCount);\r\n            if (currentDungeonCount > this.tempDungeonCount) {\r\n                this.tempDungeonCount = currentDungeonCount;\r\n                for (let i = 0; i < this.players.length; i++) {\r\n                    this.players[i].combatDetails.currentHitpoints = this.players[i].combatDetails.maxHitpoints;\r\n                    this.players[i].combatDetails.currentManapoints = this.players[i].combatDetails.maxManapoints;\r\n                    // this.simResult.playerRanOutOfMana[this.players[i].hrid] = false;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.enemies.forEach((enemy) => {\r\n            enemy.reset(this.simulationTime);\r\n            this.simResult.updateTimeSpentAlive(enemy.hrid, true, this.simulationTime);\r\n            //console.log(enemy.hrid, \"spawned\");\r\n        });\r\n\r\n        this.eventQueue.clearEventsOfType(EnrageTickEvent.type);\r\n        let enrageTickEvent = new EnrageTickEvent(this.simulationTime + ENRAGE_TICK_INTERVAL, ENRAGE_TICK_INTERVAL);\r\n        this.eventQueue.addEvent(enrageTickEvent);\r\n        this.enrageBeginTime = this.simulationTime;\r\n\r\n        this.eventQueue.clearEventsOfType(AbilityCastEndEvent.type);\r\n\r\n        // 提前检查trigger让吃喝先跑\r\n        this.checkTriggers();\r\n\r\n        this.startAttacks();\r\n    }\r\n\r\n    startAttacks() {\r\n        let units = [...this.players];\r\n        if (this.enemies) {\r\n            units.push(...this.enemies);\r\n        }\r\n\r\n        for (const unit of units) {\r\n            if (unit.combatDetails.currentHitpoints <= 0) {\r\n                continue;\r\n            }\r\n\r\n            /*-if (unit.isPlayer) {\r\n                // console.log(\"Start Attacks \" + (this.simulationTime / 1000000000));\r\n            }*/\r\n            this.addNextAttackEvent(unit);\r\n        }\r\n    }\r\n\r\n    checkParry(targets) {\r\n        let parryUnits = targets.filter((unit) => unit && unit.combatDetails.currentHitpoints > 0 && unit.combatDetails.combatStats.parry > 0);\r\n        if (parryUnits.length <= 0) {\r\n            return undefined;\r\n        }\r\n        let randomIndex = Math.floor(Math.random() * parryUnits.length);\r\n        if (parryUnits[randomIndex].combatDetails.combatStats.parry > Math.random()) {\r\n            return parryUnits[randomIndex];\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    processAutoAttackEvent(event) {\r\n        // console.log(\"source:\", event.source.hrid);\r\n        // console.log(\"aa \" + (this.simulationTime / 1000000000));\r\n\r\n        let targets = event.source.isPlayer ? this.enemies : this.players;\r\n\r\n        if (!targets) {\r\n            return;\r\n        }\r\n\r\n        const aliveTargets = targets.filter((unit) => unit && unit.combatDetails.currentHitpoints > 0);\r\n\r\n        // Maze timeout check: if an encounter is a maze and has lasted >= 2 minutes,\r\n        // attacks by enemies should trigger the maze instant-kill behavior in CombatUtilities.\r\n        const mazeTimeoutActive = this.zone && this.zone.isMaze && (this.simulationTime - this.enrageBeginTime >= 120 * ONE_SECOND);\r\n\r\n        for (let i = 0; i < aliveTargets.length; i++) {\r\n            let target = aliveTargets[i];\r\n            if (!event.source.isPlayer && aliveTargets.length > 1) {\r\n                let cumulativeThreat = 0;\r\n                let cumulativeRanges = [];\r\n                aliveTargets.forEach(player => {\r\n                    let playerThreat = player.combatDetails.combatStats.threat;\r\n                    cumulativeThreat += playerThreat;\r\n                    cumulativeRanges.push({\r\n                        player: player,\r\n                        rangeStart: cumulativeThreat - playerThreat,\r\n                        rangeEnd: cumulativeThreat\r\n                    });\r\n                });\r\n                let randomValueHit = Math.random() * cumulativeThreat;\r\n                target = cumulativeRanges.find(range => randomValueHit >= range.rangeStart && randomValueHit < range.rangeEnd).player;\r\n            }\r\n            let source = event.source;\r\n\r\n            let parryTarget = this.checkParry(targets);\r\n            if (parryTarget) {\r\n                target = source;\r\n                source = parryTarget;\r\n            }\r\n\r\n            let attackResult = CombatUtilities.processAttack(source, target, null, { mazeInstantKill: mazeTimeoutActive });\r\n            if (this.zone.isDungeon && target.isPlayer && attackResult.didHit && attackResult.damageDone > 0) {\r\n                const log = this.generateCombatLog(source, \"autoAttack\", target, attackResult);\r\n                this.addToWipeLogs(log);\r\n                // if (this.zone.isMaze && this.simulationTime - this.enrageBeginTime >= 120 * ONE_SECOND) {\r\n                //     target.combatDetails.currentHitpoints = 0;\r\n                // }\r\n            }\r\n\r\n            let mayhem = source.combatDetails.combatStats.mayhem > Math.random();\r\n\r\n            if (attackResult.didHit && source.combatDetails.combatStats.curse > 0) {\r\n                const curseExpireTime = 15000000000;\r\n                let currentCurseEvent = this.eventQueue.getMatching((event) => event.type == CurseExpirationEvent.type && event.source == target);\r\n                let currentCurseAmount = 0;\r\n                if (currentCurseEvent) currentCurseAmount = currentCurseEvent.curseAmount;\r\n                this.eventQueue.clearMatching((event) => event.type == CurseExpirationEvent.type && event.source == target);\r\n\r\n                let curseExpirationEvent = new CurseExpirationEvent(this.simulationTime + curseExpireTime, currentCurseAmount, target);\r\n                const curseBuff = {\r\n                    \"uniqueHrid\": \"/buff_uniques/curse\",\r\n                    \"typeHrid\": \"/buff_types/damage_taken\",\r\n                    \"ratioBoost\": 0,\r\n                    \"ratioBoostLevelBonus\": 0,\r\n                    \"flatBoost\": source.combatDetails.combatStats.curse * curseExpirationEvent.curseAmount,\r\n                    \"flatBoostLevelBonus\": 0,\r\n                    \"startTime\": \"0001-01-01T00:00:00Z\",\r\n                    \"duration\": curseExpireTime\r\n                };\r\n                target.addBuff(curseBuff, this.simulationTime);\r\n                this.eventQueue.addEvent(curseExpirationEvent);\r\n            }\r\n\r\n            if (source.combatDetails.combatStats.fury > 0) {\r\n                let currentFuryEvent = this.eventQueue.getMatching((event) => event.type == FuryExpirationEvent.type && event.source == source);\r\n                this.eventQueue.clearMatching((event) => event.type == FuryExpirationEvent.type && event.source == source);\r\n\r\n                const furyExpireTime = 15000000000;\r\n                const maxFuryStack = 5;\r\n\r\n                let furyAmount = 0;\r\n                if (currentFuryEvent) furyAmount = currentFuryEvent.furyAmount;\r\n\r\n                if (attackResult.didHit) {\r\n                    furyAmount = Math.min(furyAmount + 1, maxFuryStack);\r\n                } else {\r\n                    furyAmount = furyAmount / 2;\r\n                }\r\n\r\n                const furyAccuracyBuf = {\r\n                    \"uniqueHrid\": \"/buff_uniques/fury_accuracy\",\r\n                    \"typeHrid\": \"/buff_types/fury_accuracy\",\r\n                    \"ratioBoost\": furyAmount * source.combatDetails.combatStats.fury,\r\n                    \"ratioBoostLevelBonus\": 0,\r\n                    \"flatBoost\": 0,\r\n                    \"flatBoostLevelBonus\": 0,\r\n                    \"startTime\": \"0001-01-01T00:00:00Z\",\r\n                    \"duration\": furyExpireTime\r\n                };\r\n                const furyDamageBuf = {\r\n                    \"uniqueHrid\": \"/buff_uniques/fury_damage\",\r\n                    \"typeHrid\": \"/buff_types/fury_damage\",\r\n                    \"ratioBoost\": furyAmount * source.combatDetails.combatStats.fury,\r\n                    \"ratioBoostLevelBonus\": 0,\r\n                    \"flatBoost\": 0,\r\n                    \"flatBoostLevelBonus\": 0,\r\n                    \"startTime\": \"0001-01-01T00:00:00Z\",\r\n                    \"duration\": furyExpireTime\r\n                };\r\n\r\n                if (furyAmount > 0) {\r\n                    let furyExpirationEvent = new FuryExpirationEvent(this.simulationTime + furyExpireTime, furyAmount, source);\r\n                    this.eventQueue.addEvent(furyExpirationEvent);\r\n\r\n                    source.addBuff(furyAccuracyBuf, this.simulationTime);\r\n                    source.addBuff(furyDamageBuf, this.simulationTime);\r\n                }\r\n                else {\r\n                    source.removeBuff(furyAccuracyBuf);\r\n                    source.removeBuff(furyDamageBuf);\r\n                }\r\n            }\r\n\r\n            if (target.combatDetails.combatStats.weaken > 0) {\r\n                const weakenExpireTime = 15000000000;\r\n                let currentWeakenEvent = this.eventQueue.getMatching((event) => event.type == WeakenExpirationEvent.type && event.source == source);\r\n                let weakenAmount = 0;\r\n                if (currentWeakenEvent)\r\n                    weakenAmount = currentWeakenEvent.weakenAmount;\r\n                this.eventQueue.clearMatching((event) => event.type == WeakenExpirationEvent.type && event.source == source);\r\n                let weakenExpirationEvent = new WeakenExpirationEvent(this.simulationTime + 15000000000, weakenAmount, source);\r\n                const weakenBuff = {\r\n                    \"uniqueHrid\": \"/buff_uniques/weaken\",\r\n                    \"typeHrid\": \"/buff_types/damage\",\r\n                    \"ratioBoost\": -1 * target.combatDetails.combatStats.weaken * weakenExpirationEvent.weakenAmount,\r\n                    \"ratioBoostLevelBonus\": 0,\r\n                    \"flatBoost\": 0,\r\n                    \"flatBoostLevelBonus\": 0,\r\n                    \"startTime\": \"0001-01-01T00:00:00Z\",\r\n                    \"duration\": weakenExpireTime\r\n                };\r\n                source.addBuff(weakenBuff, this.simulationTime);\r\n                this.eventQueue.addEvent(weakenExpirationEvent);\r\n            }\r\n\r\n            if (!mayhem || (mayhem && attackResult.didHit) || (mayhem && i == (aliveTargets.length - 1))) {\r\n                let attackType = \"autoAttack\";\r\n                if (parryTarget) attackType = \"parry\";\r\n                this.simResult.addAttack(\r\n                    source,\r\n                    target,\r\n                    \"autoAttack\",\r\n                    attackResult.didHit ? attackResult.damageDone : \"miss\"\r\n                );\r\n            }\r\n\r\n            if (attackResult.lifeStealHeal > 0) {\r\n                this.simResult.addHitpointsGained(source, \"lifesteal\", attackResult.lifeStealHeal);\r\n            }\r\n\r\n            if (attackResult.manaLeechMana > 0) {\r\n                this.simResult.addManapointsGained(source, \"manaLeech\", attackResult.manaLeechMana);\r\n            }\r\n\r\n            if (attackResult.thornDamageDone > 0) {\r\n                this.simResult.addAttack(target, source, attackResult.thornType, attackResult.thornDamageDone);\r\n            }\r\n            if (this.zone.isDungeon && attackResult.thornDamageDone > 0 && source.isPlayer) {\r\n                const log = this.buildCombatLog(target, attackResult.thornType, source, attackResult.thornDamageDone);\r\n                this.addToWipeLogs(log);\r\n            }\r\n\r\n            if (target.combatDetails.combatStats.retaliation > 0) {\r\n                this.simResult.addAttack(target, source, \"retaliation\", attackResult.retaliationDamageDone > 0?attackResult.retaliationDamageDone:\"miss\");\r\n            }\r\n            if (this.zone.isDungeon && attackResult.retaliationDamageDone > 0 && source.isPlayer) {\r\n                const log = this.buildCombatLog(target, \"retaliation\", source, attackResult.retaliationDamageDone);\r\n                this.addToWipeLogs(log);\r\n            }\r\n\r\n            if (target.combatDetails.currentHitpoints == 0) {\r\n                this.eventQueue.clearEventsForUnit(target);\r\n                this.simResult.addDeath(target);\r\n                if (!target.isPlayer) {\r\n                    this.simResult.updateTimeSpentAlive(target.hrid, false, this.simulationTime);\r\n                }\r\n                // console.log(target.hrid, \"died\");\r\n            }\r\n\r\n            // Could die from reflect damage\r\n            if (source.combatDetails.currentHitpoints == 0 && \r\n                (attackResult.thornDamageDone != 0 || attackResult.retaliationDamageDone != 0)\r\n            ) {\r\n                this.eventQueue.clearEventsForUnit(source);\r\n                this.simResult.addDeath(source);\r\n                if (!source.isPlayer) {\r\n                    this.simResult.updateTimeSpentAlive(source.hrid, false, this.simulationTime);\r\n                }\r\n                break;\r\n            }\r\n\r\n            if (mayhem && !attackResult.didHit) {\r\n                continue;\r\n            }\r\n\r\n            if (!attackResult.didHit || parryTarget || source.combatDetails.combatStats.pierce <= Math.random()) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!this.checkEncounterEnd()) {\r\n            // console.log(\"!EncounterEnd \" + (this.simulationTime / 1000000000));\r\n            this.addNextAttackEvent(event.source);\r\n        }\r\n    }\r\n\r\n    checkEncounterEnd() {\r\n        if (this.enemies) {\r\n            let deadEnemies = this.enemies.filter((enemy) => enemy.combatDetails.currentHitpoints <= 0 && enemy.experienceRate == 0);\r\n            if (deadEnemies.length > 0) {\r\n                deadEnemies.forEach(enemy => {\r\n                    let aliveDuration = this.simulationTime - this.enrageBeginTime;\r\n                    if (aliveDuration > enemy.enrageTime) {\r\n                        aliveDuration = enemy.enrageTime;\r\n                    }\r\n                    enemy.experienceRate = 1.0 + aliveDuration / enemy.enrageTime;\r\n                    // console.log(enemy.hrid, \"alive duration\", aliveDuration, \"exp rate\", enemy.experienceRate);\r\n                })\r\n            }\r\n        }\r\n\r\n        let encounterEnded = false;\r\n\r\n        if (this.enemies && !this.enemies.some((enemy) => enemy.combatDetails.currentHitpoints > 0)) {\r\n            this.eventQueue.clearEventsOfType(AutoAttackEvent.type);\r\n            // this.eventQueue.clearEventsOfType(AbilityCastEndEvent.type);\r\n            let enemyRespawnEvent = new EnemyRespawnEvent(this.simulationTime + ENEMY_RESPAWN_INTERVAL);\r\n            this.eventQueue.addEvent(enemyRespawnEvent);\r\n\r\n            //calc exp before clear\r\n            if (this.enemies.some(enemy => enemy.experienceRate <= 0)) {\r\n                console.log(\"WARN: Some enemies have no experience rate\");\r\n            }\r\n\r\n            let totalExp = this.enemies.map(enemy => enemy.experience * enemy.experienceRate).reduce((a, b) => a + b, 0);\r\n            this.players.forEach(player => {\r\n                this.simResult.addExperienceGain(player, totalExp / this.players.length);\r\n            });\r\n\r\n            this.enemies = null;\r\n\r\n            if (this.zone.isDungeon) {\r\n                this.simResult.updateTimeSpentAlive(\"#\" + (this.zone.encountersKilled - 1).toString(), false, this.simulationTime);\r\n                if (this.zone.encountersKilled > this.zone.dungeonSpawnInfo.maxWaves) {\r\n                    this.simResult.updateDungenonFinish(\"#1\", this.simulationTime);\r\n                    this.simResult.lastDungeonFinishTime = this.simulationTime;\r\n                }\r\n            }\r\n            this.simResult.addEncounterEnd();\r\n            this.simResult.lastEncounterFinishTime = this.simulationTime;\r\n            // console.log(\"All enemies died\");\r\n\r\n            encounterEnded = true;\r\n            // console.log(\"encounter end \" + (this.simulationTime / 1000000000))\r\n        }\r\n\r\n        this.players.forEach(player => {\r\n            if ((player.combatDetails.currentHitpoints <= 0) && !this.eventQueue.containsEventOfTypeAndHrid(PlayerRespawnEvent.type, player.hrid)) {\r\n                if (!this.zone.isDungeon) {\r\n                    let playerRespawnEvent = new PlayerRespawnEvent(this.simulationTime + PLAYER_RESPAWN_INTERVAL, player.hrid);\r\n                    this.eventQueue.addEvent(playerRespawnEvent);\r\n                }\r\n                this.simResult.addRanOutOfManaCount(player, false, this.simulationTime);\r\n                // console.log(player.hrid + \" died at \" + (this.simulationTime / 1000000000) + 'in wave #' + (this.zone.encountersKilled - 1) + ' with ememies: ' + this.enemies?.map(enemy => (enemy.hrid+\"(\"+(enemy.combatDetails.currentHitpoints*100/enemy.combatDetails.maxHitpoints).toFixed(2)+\"%)\")).join(\", \"));\r\n            }\r\n        });\r\n\r\n        if (\r\n            !this.players.some((player) => player.combatDetails.currentHitpoints > 0)\r\n        ) {\r\n            if (this.zone.isDungeon) {\r\n                // 安全日志，避免 this.enemies 为 null 时触发异常\r\n                {\r\n                    let enemiesDesc = 'none';\r\n                    if (this.enemies && this.enemies.length > 0) {\r\n                        enemiesDesc = this.enemies.map(enemy => {\r\n                            if (!enemy) return 'UNKNOWN';\r\n                            const hp = enemy.combatDetails?.currentHitpoints ?? 0;\r\n                            const max = enemy.combatDetails?.maxHitpoints ?? 1;\r\n                            const pct = ((hp * 100) / (max || 1)).toFixed(2);\r\n                            return `${enemy.hrid}(${pct}%)`;\r\n                        }).join(', ');\r\n                    }\r\n                    console.log(`All Players died at wave #${this.zone.encountersKilled - 1} with enemies: ${enemiesDesc}`);\r\n                }\r\n\r\n                this.saveWipeLogsToSimResult(this.zone.encountersKilled - 1);\r\n                // console.log(this.simResult)\r\n                this.wipeLogs.index = 0;\r\n                this.wipeLogs.count = 0;\r\n\r\n                // 地下城团灭：只清除战斗相关事件，保留buff过期检查和CD事件\r\n                this.eventQueue.clearEventsOfType(AutoAttackEvent.type);\r\n                this.eventQueue.clearEventsOfType(AbilityCastEndEvent.type);\r\n                this.eventQueue.clearEventsOfType(DamageOverTimeEvent.type);\r\n                this.eventQueue.clearEventsOfType(ConsumableTickEvent.type);\r\n                this.eventQueue.clearEventsOfType(RegenTickEvent.type);\r\n                this.eventQueue.clearEventsOfType(EnrageTickEvent.type);\r\n                this.eventQueue.clearEventsOfType(StunExpirationEvent.type);\r\n                this.eventQueue.clearEventsOfType(BlindExpirationEvent.type);\r\n                this.eventQueue.clearEventsOfType(SilenceExpirationEvent.type);\r\n                this.eventQueue.clearEventsOfType(AwaitCooldownEvent.type);\r\n                this.enemies = null;\r\n\r\n                let combatStartEvent = new CombatStartEvent(this.simulationTime + RESTART_INTERVAL);\r\n                this.eventQueue.addEvent(combatStartEvent);\r\n            } else {\r\n                this.eventQueue.clearEventsOfType(AutoAttackEvent.type);\r\n                this.eventQueue.clearEventsOfType(AbilityCastEndEvent.type);\r\n            }\r\n            // console.log(\"All Players died\");\r\n            encounterEnded = true;\r\n            this.allPlayersDead = true;\r\n        }\r\n\r\n        return encounterEnded;\r\n    }\r\n\r\n    addNextAttackEvent(source) {\r\n        if (this.eventQueue.getMatching((event) => (event.type == AbilityCastEndEvent.type || event.type == AutoAttackEvent.type)&& event.source == source)) {\r\n            return;\r\n        }\r\n\r\n        let target;\r\n        let friendlies;\r\n        let enemies;\r\n        if (source.isPlayer) {\r\n            target = CombatUtilities.getTarget(this.enemies);\r\n            friendlies = this.players;\r\n            enemies = this.enemies;\r\n        } else {\r\n            target = CombatUtilities.getTarget(this.players);\r\n            friendlies = this.enemies;\r\n            enemies = this.players;\r\n        }\r\n\r\n        let usedAbility = false;\r\n        let skipNextAbility = false; \r\n\r\n        source.abilities\r\n            .filter((ability) => ability != null)\r\n            .forEach((ability) => {\r\n                if (!usedAbility && !skipNextAbility && ability.shouldTrigger(this.simulationTime, source, target, friendlies, enemies)) {\r\n                    if (!this.canUseAbility(source, ability, true)) {\r\n                        skipNextAbility = true;\r\n                    }\r\n\r\n                    if (!skipNextAbility) {\r\n                        let castDuration = ability.castDuration;\r\n                        castDuration /= (1 + source.combatDetails.combatStats.castSpeed)\r\n                        let abilityCastEndEvent = new AbilityCastEndEvent(this.simulationTime + castDuration, source, ability);\r\n                        this.eventQueue.addEvent(abilityCastEndEvent);\r\n                        /*-if (source.isPlayer) {\r\n                            let haste = source.combatDetails.combatStats.abilityHaste;\r\n                            let cooldownDuration = ability.cooldownDuration;\r\n                            if (haste > 0) {\r\n                                cooldownDuration = cooldownDuration * 100 / (100 + haste);\r\n                            }\r\n                            // console.log((this.simulationTime / 1000000000) + \" Casting \" + ability.hrid + \" Cast time \" + (castDuration / 1e9) + \" Off CD at \" + ((this.simulationTime + cooldownDuration + castDuration) / 1e9) + \" CD \" + ((cooldownDuration) / 1e9));\r\n                        }*/\r\n                        usedAbility = true;\r\n                    }\r\n                }\r\n            });\r\n\r\n        if (usedAbility) {\r\n            source.isOutOfMana = false;\r\n            return;\r\n        }\r\n\r\n        if (!enemies) {\r\n            return;\r\n        }\r\n\r\n        if (!source.isBlinded) {\r\n            let autoAttackEvent = new AutoAttackEvent(\r\n                this.simulationTime + source.combatDetails.combatStats.attackInterval,\r\n                source\r\n            );\r\n            /*-if (source.isPlayer) {\r\n                // console.log(\"next attack \" + ((this.simulationTime + source.combatDetails.combatStats.attackInterval) / 1e9))\r\n            }*/\r\n            this.eventQueue.addEvent(autoAttackEvent);\r\n        } else {\r\n            source.isOutOfMana = true;\r\n        }\r\n    }\r\n\r\n    processConsumableTickEvent(event) {\r\n        if (event.consumable.hitpointRestore > 0) {\r\n            let tickValue = CombatUtilities.calculateTickValue(\r\n                event.consumable.hitpointRestore,\r\n                event.totalTicks,\r\n                event.currentTick\r\n            );\r\n            let hitpointsAdded = event.source.addHitpoints(tickValue);\r\n            this.simResult.addHitpointsGained(event.source, event.consumable.hrid, hitpointsAdded);\r\n            // console.log(\"Added hitpoints:\", hitpointsAdded);\r\n        }\r\n\r\n        if (event.consumable.manapointRestore > 0) {\r\n            let tickValue = CombatUtilities.calculateTickValue(\r\n                event.consumable.manapointRestore,\r\n                event.totalTicks,\r\n                event.currentTick\r\n            );\r\n            let manapointsAdded = event.source.addManapoints(tickValue);\r\n            this.simResult.addManapointsGained(event.source, event.consumable.hrid, manapointsAdded);\r\n            // console.log(\"Added manapoints:\", manapointsAdded);\r\n\r\n            // when oom check ability trigger\r\n            if (event.source.isOutOfMana) {\r\n                let awaitCooldownEvent = new AwaitCooldownEvent(\r\n                    this.simulationTime,\r\n                    event.source\r\n                );\r\n                this.eventQueue.addEvent(awaitCooldownEvent);\r\n            }\r\n        }\r\n\r\n        if (event.currentTick < event.totalTicks) {\r\n            let consumableTickEvent = new ConsumableTickEvent(\r\n                this.simulationTime + HOT_TICK_INTERVAL,\r\n                event.source,\r\n                event.consumable,\r\n                event.totalTicks,\r\n                event.currentTick + 1\r\n            );\r\n            this.eventQueue.addEvent(consumableTickEvent);\r\n        }\r\n    }\r\n\r\n    processDamageOverTimeTickEvent(event) {\r\n        let tickDamage = CombatUtilities.calculateTickValue(event.damage, event.totalTicks, event.currentTick);\r\n        let damage = Math.min(tickDamage, event.target.combatDetails.currentHitpoints);\r\n\r\n        event.target.combatDetails.currentHitpoints -= damage;\r\n        this.simResult.addAttack(event.sourceRef, event.target, \"damageOverTime\", damage);\r\n\r\n        const log = this.buildCombatLog(\"\", \"damageOverTime\", event.target, damage);\r\n        this.addToWipeLogs(log);\r\n\r\n        // console.log(event.target.hrid, \"bleed for\", damage);\r\n\r\n        if (event.currentTick < event.totalTicks) {\r\n            let damageOverTimeTickEvent = new DamageOverTimeEvent(\r\n                this.simulationTime + DOT_TICK_INTERVAL,\r\n                event.sourceRef,\r\n                event.target,\r\n                event.damage,\r\n                event.totalTicks,\r\n                event.currentTick + 1,\r\n                event.combatStyleHrid\r\n            );\r\n            this.eventQueue.addEvent(damageOverTimeTickEvent);\r\n        }\r\n\r\n        if (event.target.combatDetails.currentHitpoints == 0) {\r\n            this.eventQueue.clearEventsForUnit(event.target);\r\n            this.simResult.addDeath(event.target);\r\n            if (!event.target.isPlayer) {\r\n                this.simResult.updateTimeSpentAlive(event.target.hrid, false, this.simulationTime);\r\n            }\r\n        }\r\n\r\n        this.checkEncounterEnd();\r\n    }\r\n\r\n    processRegenTickEvent(event) {\r\n        let units = [...this.players];\r\n\r\n        // regen of emeny always set to 0, ingore the proc time\r\n        // if (this.enemies) {\r\n        //     units.push(...this.enemies);\r\n        // }\r\n\r\n        for (const unit of units) {\r\n            if (unit.combatDetails.currentHitpoints <= 0) {\r\n                continue;\r\n            }\r\n\r\n            let hitpointRegen = Math.floor(unit.combatDetails.maxHitpoints * unit.combatDetails.combatStats.hpRegenPer10);\r\n            let hitpointsAdded = unit.addHitpoints(hitpointRegen);\r\n            this.simResult.addHitpointsGained(unit, \"regen\", hitpointsAdded);\r\n            // console.log(\"Added hitpoints:\", hitpointsAdded);\r\n\r\n            let manapointRegen = Math.floor(unit.combatDetails.maxManapoints * unit.combatDetails.combatStats.mpRegenPer10);\r\n            let manapointsAdded = unit.addManapoints(manapointRegen);\r\n            this.simResult.addManapointsGained(unit, \"regen\", manapointsAdded);\r\n            // console.log(\"Added manapoints:\", manapointsAdded);\r\n\r\n            // when oom check ability trigger\r\n            if (unit.isOutOfMana) {\r\n                let awaitCooldownEvent = new AwaitCooldownEvent(\r\n                    this.simulationTime,\r\n                    unit\r\n                );\r\n                this.eventQueue.addEvent(awaitCooldownEvent);\r\n            }\r\n        }\r\n\r\n        let regenTickEvent = new RegenTickEvent(this.simulationTime + REGEN_TICK_INTERVAL);\r\n        this.eventQueue.addEvent(regenTickEvent);\r\n    }\r\n\r\n    processCheckBuffExpirationEvent(event) {\r\n        event.source.removeExpiredBuffs(this.simulationTime);\r\n    }\r\n\r\n    processStunExpirationEvent(event) {\r\n        event.source.isStunned = false;\r\n        // console.log(\"Stun \" + (this.simulationTime / 1000000000));\r\n        this.addNextAttackEvent(event.source);\r\n    }\r\n\r\n    processBlindExpirationEvent(event) {\r\n        event.source.isBlinded = false;\r\n        this.addNextAttackEvent(event.source);\r\n    }\r\n\r\n    processSilenceExpirationEvent(event) {\r\n        event.source.isSilenced = false;\r\n    }\r\n\r\n    processCurseExpirationEvent(event) {\r\n        event.source.removeExpiredBuffs(this.simulationTime);\r\n    }\r\n\r\n    processWeakenExpirationEvent(event) {\r\n        event.source.removeExpiredBuffs(this.simulationTime);\r\n    }\r\n\r\n    processFuryExpirationEvent(event) {\r\n        event.source.removeExpiredBuffs(this.simulationTime);\r\n        console.log(\"Fury Timeout\");\r\n    }\r\n\r\n    processEnrageTickEvent(event) {\r\n        if (!this.enemies) return;\r\n        const maxEnrageStack = 10;\r\n        this.enemies.filter((enemy) => enemy.combatDetails.currentHitpoints > 0).forEach((enemy) => {\r\n            let nowStack = Math.min(maxEnrageStack, Math.floor(event.encounterTime / enemy.enrageTime));\r\n\r\n            if (nowStack <= 0) {\r\n                return;\r\n            }\r\n\r\n            console.log(enemy.hrid, nowStack, \" stack Enrage at \", (event.encounterTime / ONE_SECOND));\r\n\r\n            const enrageDamageBuff = {\r\n                    \"uniqueHrid\": \"/buff_uniques/enrage_damage\",\r\n                    \"typeHrid\": \"/buff_types/damage\",\r\n                    \"ratioBoost\": nowStack * 0.1,\r\n                    \"ratioBoostLevelBonus\": 0,\r\n                    \"flatBoost\": 0,\r\n                    \"flatBoostLevelBonus\": 0,\r\n                    \"startTime\": \"0001-01-01T00:00:00Z\",\r\n                    \"duration\": ENRAGE_TICK_INTERVAL\r\n            };\r\n            const enrageAccuracyBuff = {\r\n                    \"uniqueHrid\": \"/buff_uniques/enrage_accuracy\",\r\n                    \"typeHrid\": \"/buff_types/accuracy\",\r\n                    \"ratioBoost\": nowStack * 0.1,\r\n                    \"ratioBoostLevelBonus\": 0,\r\n                    \"flatBoost\": 0,\r\n                    \"flatBoostLevelBonus\": 0,\r\n                    \"startTime\": \"0001-01-01T00:00:00Z\",\r\n                    \"duration\": ENRAGE_TICK_INTERVAL\r\n            };\r\n            enemy.addBuff(enrageDamageBuff);\r\n            enemy.addBuff(enrageAccuracyBuff);\r\n            \r\n            this.simResult.maxEnrageStack = Math.max(this.simResult.maxEnrageStack, nowStack);\r\n        });\r\n\r\n        let enrageTickEvent = new EnrageTickEvent(this.simulationTime + ENRAGE_TICK_INTERVAL, event.encounterTime + ENRAGE_TICK_INTERVAL);\r\n        this.eventQueue.addEvent(enrageTickEvent);\r\n    }\r\n\r\n    checkTriggers() {\r\n        let triggeredSomething;\r\n\r\n        do {\r\n            triggeredSomething = false;\r\n\r\n            this.players\r\n                .filter((player) => player.combatDetails.currentHitpoints > 0)\r\n                .forEach((player) => {\r\n                    if (this.checkTriggersForUnit(player, this.players, this.enemies)) {\r\n                        triggeredSomething = true;\r\n                    }\r\n                });\r\n\r\n            if (this.enemies) {\r\n                this.enemies\r\n                    .filter((enemy) => enemy.combatDetails.currentHitpoints > 0)\r\n                    .forEach((enemy) => {\r\n                        if (this.checkTriggersForUnit(enemy, this.enemies, this.players)) {\r\n                            triggeredSomething = true;\r\n                        }\r\n                    });\r\n            }\r\n        } while (triggeredSomething);\r\n    }\r\n\r\n    checkTriggersForUnit(unit, friendlies, enemies) {\r\n        if (unit.combatDetails.currentHitpoints <= 0) {\r\n            throw new Error(\"Checking triggers for a dead unit\");\r\n        }\r\n\r\n        let triggeredSomething = false;\r\n        let target = CombatUtilities.getTarget(enemies);\r\n\r\n        for (const food of unit.food) {\r\n            if (food && food.shouldTrigger(this.simulationTime, unit, target, friendlies, enemies)) {\r\n                let result = this.tryUseConsumable(unit, food);\r\n                if (result) {\r\n                    triggeredSomething = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const drink of unit.drinks) {\r\n            if (drink && drink.shouldTrigger(this.simulationTime, unit, target, friendlies, enemies)) {\r\n                let result = this.tryUseConsumable(unit, drink);\r\n                if (result) {\r\n                    triggeredSomething = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return triggeredSomething;\r\n    }\r\n\r\n    tryUseConsumable(source, consumable) {\r\n        // console.log(\"Consuming:\", consumable);\r\n\r\n        if (source.combatDetails.currentHitpoints <= 0) {\r\n            return false;\r\n        }\r\n\r\n        consumable.lastUsed = this.simulationTime;\r\n        let consumeCooldown = consumable.cooldownDuration;\r\n        if (source.combatDetails.combatStats.drinkConcentration > 0 && consumable.catagoryHrid.includes(\"drink\")) {\r\n            consumeCooldown = consumeCooldown / (1 + source.combatDetails.combatStats.drinkConcentration);\r\n        } else if (source.combatDetails.combatStats.foodHaste > 0 && consumable.catagoryHrid.includes(\"food\")) {\r\n            consumeCooldown = consumeCooldown / (1 + source.combatDetails.combatStats.foodHaste);\r\n        }\r\n        let cooldownReadyEvent = new CooldownReadyEvent(this.simulationTime + consumeCooldown);\r\n        this.eventQueue.addEvent(cooldownReadyEvent);\r\n\r\n        this.simResult.addConsumableUse(source, consumable);\r\n\r\n        if (consumable.recoveryDuration == 0) {\r\n            if (consumable.hitpointRestore > 0) {\r\n                let hitpointsAdded = source.addHitpoints(consumable.hitpointRestore);\r\n                this.simResult.addHitpointsGained(source, consumable.hrid, hitpointsAdded);\r\n                // console.log(\"Added hitpoints:\", hitpointsAdded);\r\n            }\r\n\r\n            if (consumable.manapointRestore > 0) {\r\n                let manapointsAdded = source.addManapoints(consumable.manapointRestore);\r\n                this.simResult.addManapointsGained(source, consumable.hrid, manapointsAdded);\r\n                // console.log(\"Added manapoints:\", manapointsAdded);\r\n\r\n                // when oom check ability trigger\r\n                if (source.isOutOfMana) {\r\n                    let awaitCooldownEvent = new AwaitCooldownEvent(\r\n                        this.simulationTime,\r\n                        source\r\n                    );\r\n                    this.eventQueue.addEvent(awaitCooldownEvent);\r\n                }\r\n            }\r\n        } else {\r\n            let consumableTickEvent = new ConsumableTickEvent(\r\n                this.simulationTime + HOT_TICK_INTERVAL,\r\n                source,\r\n                consumable,\r\n                consumable.recoveryDuration / HOT_TICK_INTERVAL,\r\n                1\r\n            );\r\n            this.eventQueue.addEvent(consumableTickEvent);\r\n        }\r\n\r\n        for (const buff of consumable.buffs) {\r\n            let currentBuff = structuredClone(buff);\r\n            if (source.combatDetails.combatStats.drinkConcentration > 0 && consumable.catagoryHrid.includes(\"drink\")) {\r\n                currentBuff.ratioBoost *= (1 + source.combatDetails.combatStats.drinkConcentration);\r\n                currentBuff.flatBoost *= (1 + source.combatDetails.combatStats.drinkConcentration);\r\n                currentBuff.duration = currentBuff.duration / (1 + source.combatDetails.combatStats.drinkConcentration);\r\n            }\r\n            source.addBuff(currentBuff, this.simulationTime);\r\n            // console.log(\"Added buff:\", currentBuff);\r\n            let checkBuffExpirationEvent = new CheckBuffExpirationEvent(this.simulationTime + currentBuff.duration, source);\r\n            this.eventQueue.addEvent(checkBuffExpirationEvent);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    canUseAbility(source, ability, oomCheck) {\r\n        if (source.combatDetails.currentHitpoints <= 0) {\r\n            return false;\r\n        }\r\n\r\n        if (source.combatDetails.currentManapoints < ability.manaCost) {\r\n            if (source.isPlayer && oomCheck) {\r\n                // if (this.simResult.playerRanOutOfMana[source.hrid] == false) {\r\n                //     console.log(source.hrid + \" ran out of mana\" + ' at wave #' + (this.zone.encountersKilled - 1) + ' at time ' + this.simulationTime / 1000000000 + 's');\r\n                // }\r\n                this.simResult.addRanOutOfManaCount(source, true, this.simulationTime);\r\n            }\r\n            return false;\r\n        }\r\n        if (source.isPlayer && oomCheck) {\r\n            this.simResult.addRanOutOfManaCount(source, false, this.simulationTime);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    tryUseAbility(source, ability) {\r\n\r\n        if (!this.canUseAbility(source, ability, true)) {\r\n            // console.log(\"Falseeeeeee\");\r\n            return false;\r\n        }\r\n\r\n        // console.log(\"Casting:\", ability);\r\n\r\n        if (source.isPlayer) {\r\n            if (source.abilityManaCosts.has(ability.hrid)) {\r\n                source.abilityManaCosts.set(ability.hrid, source.abilityManaCosts.get(ability.hrid) + ability.manaCost);\r\n            } else {\r\n                source.abilityManaCosts.set(ability.hrid, ability.manaCost);\r\n            }\r\n        }\r\n\r\n        source.combatDetails.currentManapoints -= ability.manaCost;\r\n\r\n        ability.lastUsed = this.simulationTime;\r\n\r\n        let haste = source.combatDetails.combatStats.abilityHaste;\r\n        let cooldownDuration = ability.cooldownDuration;\r\n        if (haste > 0) {\r\n            cooldownDuration = cooldownDuration * 100 / (100 + haste);\r\n        }\r\n\r\n        /*-if (source.isPlayer) {\r\n            let castDuration = ability.castDuration;\r\n            castDuration /= (1 + source.combatDetails.combatStats.castSpeed)\r\n            // console.log((this.simulationTime / 1000000000) + \" Used ability \" + ability.hrid + \" Cast time \" + (castDuration / 1e9));\r\n        }*/\r\n\r\n        let todoAbilities = [ability];\r\n\r\n        if (source.combatDetails.combatStats.blaze > 0 && Math.random() < source.combatDetails.combatStats.blaze) {\r\n            todoAbilities.push(new Ability(\"blaze\"));\r\n        }\r\n\r\n        if (source.combatDetails.combatStats.bloom > 0 && Math.random() < source.combatDetails.combatStats.bloom) {\r\n            todoAbilities.push(new Ability(\"bloom\"));\r\n        }\r\n\r\n        for (const todoAbility of todoAbilities) {\r\n            for (const abilityEffect of todoAbility.abilityEffects) {\r\n                switch (abilityEffect.effectType) {\r\n                    case \"/ability_effect_types/buff\":\r\n                        this.processAbilityBuffEffect(source, todoAbility, abilityEffect);\r\n                        break;\r\n                    case \"/ability_effect_types/damage\":\r\n                        this.processAbilityDamageEffect(source, todoAbility, abilityEffect);\r\n                        break;\r\n                    case \"/ability_effect_types/heal\":\r\n                        this.processAbilityHealEffect(source, todoAbility, abilityEffect);\r\n                        break;\r\n                    case \"/ability_effect_types/spend_hp\":\r\n                        this.processAbilitySpendHpEffect(source, todoAbility, abilityEffect);\r\n                        break;\r\n                    case \"/ability_effect_types/revive\":\r\n                        this.processAbilityReviveEffect(source, todoAbility, abilityEffect);\r\n                        break;\r\n                    case \"/ability_effect_types/promote\":\r\n                        this.eventQueue.clearEventsForUnit(source);\r\n                        source = this.processAbilityPromoteEffect(source, todoAbility, abilityEffect);\r\n                        this.addNextAttackEvent(source);\r\n                        break;\r\n                    default:\r\n                        throw new Error(\"Unsupported effect type for ability: \" + todoAbility.hrid + \" effectType: \" + abilityEffect.effectType);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (source.combatDetails.combatStats.ripple > 0 && Math.random() < source.combatDetails.combatStats.ripple) {\r\n            let manapointsAdded = source.addManapoints(10);\r\n            this.simResult.addManapointsGained(source, \"ripple\", manapointsAdded);\r\n            for (const ability of source.abilities) {\r\n                if (ability && ability.lastUsed) {\r\n                    const remainingCooldown = ability.lastUsed + ability.cooldownDuration - this.simulationTime;\r\n                    if (remainingCooldown > 0) {\r\n                        ability.lastUsed = Math.max(ability.lastUsed - ONE_SECOND * 2, this.simulationTime - ability.cooldownDuration);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.addNextAttackEvent(source);\r\n\r\n        // Could die from reflect damage\r\n        if (source.combatDetails.currentHitpoints == 0) {\r\n            this.eventQueue.clearEventsForUnit(source);\r\n            this.simResult.addDeath(source);\r\n            if (!source.isPlayer) {\r\n                this.simResult.updateTimeSpentAlive(source.hrid, false, this.simulationTime);\r\n            }\r\n        }\r\n\r\n        this.checkEncounterEnd();\r\n\r\n        return true;\r\n    }\r\n\r\n    processAbilityBuffEffect(source, ability, abilityEffect) {\r\n        if (abilityEffect.targetType == \"allAllies\") {\r\n            // targets may be null when there are no enemies; use empty array fallback to avoid exceptions\r\n            let targets = source.isPlayer ? this.players : (this.enemies || []);\r\n            for (const target of targets.filter((unit) => unit && unit.combatDetails.currentHitpoints > 0)) {\r\n                for (const buff of abilityEffect.buffs) {\r\n                    if (ability.isSpecialAbility && buff.multiplierForSkillHrid && buff.multiplierPerSkillLevel > 0) {\r\n                        let multiplier = 1.0 + source.combatDetails[buff.multiplierForSkillHrid.split('/')[2] + 'Level'] * buff.multiplierPerSkillLevel;\r\n                        let currentBuff = structuredClone(buff);\r\n                        currentBuff.flatBoost *= multiplier;\r\n                        currentBuff.ratioBoost *= multiplier;\r\n                        target.addBuff(currentBuff, this.simulationTime);\r\n                    } else {\r\n                        target.addBuff(buff, this.simulationTime);\r\n                    }\r\n                    let checkBuffExpirationEvent = new CheckBuffExpirationEvent(this.simulationTime + buff.duration, target);\r\n                    this.eventQueue.addEvent(checkBuffExpirationEvent);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (abilityEffect.targetType != \"self\") {\r\n            throw new Error(\"Unsupported target type for buff ability effect: \" + ability.hrid);\r\n        }\r\n\r\n        for (const buff of abilityEffect.buffs) {\r\n            source.addBuff(buff, this.simulationTime);\r\n            // console.log(\"Added buff:\", abilityEffect.buff);\r\n            let checkBuffExpirationEvent = new CheckBuffExpirationEvent(this.simulationTime + buff.duration, source);\r\n            this.eventQueue.addEvent(checkBuffExpirationEvent);\r\n        }\r\n    }\r\n\r\n    processAbilityDamageEffect(source, ability, abilityEffect) {\r\n        let targets;\r\n        switch (abilityEffect.targetType) {\r\n            case \"enemy\":\r\n            case \"allEnemies\":\r\n                targets = source.isPlayer ? this.enemies : this.players;\r\n                break;\r\n            default:\r\n                throw new Error(\"Unsupported target type for damage ability effect: \" + ability.hrid);\r\n        }\r\n\r\n        if (!targets) {\r\n            return;\r\n        }\r\n\r\n        // Maze timeout: used to trigger instant-kill behavior for maze encounters\r\n        const mazeTimeoutActive = this.zone && this.zone.isMaze && (this.simulationTime - this.enrageBeginTime >= 120 * ONE_SECOND);\r\n\r\n        let avoidTarget = [];\r\n\r\n        let isSkipParry = false;\r\n\r\n        for (let target of targets.filter((unit) => unit && unit.combatDetails.currentHitpoints > 0)) {\r\n            let parryTarget = undefined;\r\n            if (!isSkipParry) {\r\n                parryTarget = this.checkParry(targets);\r\n                isSkipParry = true; //  parry check only once on first target\r\n            }\r\n            \r\n            if (parryTarget) {\r\n                let tempTarget = source;\r\n                let tempSource = parryTarget;\r\n\r\n                let attackResult = CombatUtilities.processAttack(tempSource, tempTarget, null, { mazeInstantKill: mazeTimeoutActive });\r\n\r\n                this.simResult.addAttack(\r\n                    tempSource,\r\n                    tempTarget,\r\n                    \"parry\",\r\n                    attackResult.didHit ? attackResult.damageDone : \"miss\"\r\n                );\r\n\r\n                if (attackResult.lifeStealHeal > 0) {\r\n                    this.simResult.addHitpointsGained(tempSource, \"lifesteal\", attackResult.lifeStealHeal);\r\n                }\r\n\r\n                if (attackResult.manaLeechMana > 0) {\r\n                    this.simResult.addManapointsGained(tempSource, \"manaLeech\", attackResult.manaLeechMana);\r\n                }\r\n\r\n                if (attackResult.thornDamageDone > 0) {\r\n                    this.simResult.addAttack(tempTarget, tempSource, attackResult.thornType, attackResult.thornDamageDone);\r\n                }\r\n                if (tempTarget.combatDetails.combatStats.retaliation > 0) {\r\n                    this.simResult.addAttack(tempTarget, tempSource, \"retaliation\", attackResult.retaliationDamageDone > 0 ? attackResult.retaliationDamageDone : \"miss\");\r\n                }\r\n\r\n                if (tempTarget.combatDetails.currentHitpoints == 0) {\r\n                    this.eventQueue.clearEventsForUnit(tempTarget);\r\n                    this.simResult.addDeath(tempTarget);\r\n                    if (!tempTarget.isPlayer) {\r\n                        this.simResult.updateTimeSpentAlive(tempTarget.hrid, false, this.simulationTime);\r\n                    }\r\n                    // console.log(tempTarget.hrid, \"died\");\r\n                }\r\n\r\n                // Could die from reflect damage\r\n                if (tempSource.combatDetails.currentHitpoints == 0 && \r\n                    (attackResult.thornDamageDone != 0 || attackResult.retaliationDamageDone != 0)\r\n                ) {\r\n                    this.eventQueue.clearEventsForUnit(tempSource);\r\n                    this.simResult.addDeath(tempSource);\r\n                    if (!tempSource.isPlayer) {\r\n                        this.simResult.updateTimeSpentAlive(tempSource.hrid, false, this.simulationTime);\r\n                    }\r\n                }\r\n            } else {\r\n                targets = targets.filter((unit) => unit && !avoidTarget.includes(unit.hrid) && unit.combatDetails.currentHitpoints > 0);\r\n                if (!source.isPlayer && targets.length > 0 && abilityEffect.targetType == \"enemy\") {\r\n                    let cumulativeThreat = 0;\r\n                    let cumulativeRanges = [];\r\n                    targets.forEach(player => {\r\n                        let playerThreat = player.combatDetails.combatStats.threat;\r\n                        cumulativeThreat += playerThreat;\r\n                        cumulativeRanges.push({\r\n                            player: player,\r\n                            rangeStart: cumulativeThreat - playerThreat,\r\n                            rangeEnd: cumulativeThreat\r\n                        });\r\n                    });\r\n                    let randomValueHit = Math.random() * cumulativeThreat;\r\n                    target = cumulativeRanges.find(range => randomValueHit >= range.rangeStart && randomValueHit < range.rangeEnd).player;\r\n                    avoidTarget.push(target.hrid);\r\n                }\r\n                if (targets.length <= 0) {\r\n                    break;\r\n                }\r\n\r\n                let attackResult = CombatUtilities.processAttack(source, target, abilityEffect, { mazeInstantKill: (this.zone && this.zone.isMaze && (this.simulationTime - this.enrageBeginTime >= 120 * ONE_SECOND)) });\r\n\r\n                if (this.zone.isDungeon && target.isPlayer && attackResult.didHit && attackResult.damageDone > 0) {\r\n                    const log = this.generateCombatLog(source, ability.hrid, target, attackResult);\r\n                    this.addToWipeLogs(log);\r\n                }\r\n\r\n                if (attackResult.hpDrain > 0) {\r\n                    this.simResult.addHitpointsGained(source, ability.hrid, attackResult.hpDrain);\r\n                }\r\n\r\n                if (attackResult.didHit && abilityEffect.buffs) {\r\n                    for (const buff of abilityEffect.buffs) {\r\n                        target.addBuff(buff, this.simulationTime);\r\n                        let checkBuffExpirationEvent = new CheckBuffExpirationEvent(\r\n                            this.simulationTime + buff.duration,\r\n                            target\r\n                        );\r\n                        this.eventQueue.addEvent(checkBuffExpirationEvent);\r\n                    }\r\n                }\r\n\r\n                if (abilityEffect.damageOverTimeRatio > 0 && attackResult.damageDone > 0) {\r\n                    let damageOverTimeEvent = new DamageOverTimeEvent(\r\n                        this.simulationTime + DOT_TICK_INTERVAL,\r\n                        source,\r\n                        target,\r\n                        attackResult.damageDone * abilityEffect.damageOverTimeRatio,\r\n                        abilityEffect.damageOverTimeDuration / DOT_TICK_INTERVAL,\r\n                        1, abilityEffect.combatStyleHrid\r\n                    );\r\n                    this.eventQueue.addEvent(damageOverTimeEvent);\r\n                }\r\n\r\n                if (attackResult.didHit && abilityEffect.stunChance > 0 && Math.random() < (abilityEffect.stunChance * 100 / (100 + target.combatDetails.combatStats.tenacity))) {\r\n                    target.isStunned = true;\r\n                    target.stunExpireTime = this.simulationTime + abilityEffect.stunDuration;\r\n                    this.eventQueue.clearMatching((event) => (event.type == AutoAttackEvent.type || event.type == AbilityCastEndEvent.type || event.type == StunExpirationEvent.type) && event.source == target);\r\n                    let stunExpirationEvent = new StunExpirationEvent(target.stunExpireTime, target);\r\n                    this.eventQueue.addEvent(stunExpirationEvent);\r\n                }\r\n\r\n                if (attackResult.didHit && abilityEffect.blindChance > 0 && Math.random() < (abilityEffect.blindChance * 100 / (100 + target.combatDetails.combatStats.tenacity))) {\r\n                    target.isBlinded = true;\r\n                    target.blindExpireTime = this.simulationTime + abilityEffect.blindDuration;\r\n                    this.eventQueue.clearMatching((event) => event.type == BlindExpirationEvent.type && event.source == target)\r\n                    if (this.eventQueue.clearMatching((event) => event.type == AutoAttackEvent.type && event.source == target)) {\r\n                        // console.log(\"Blind \" + (this.simulationTime / 1000000000));\r\n                        this.addNextAttackEvent(target);\r\n                    }\r\n                    let blindExpirationEvent = new BlindExpirationEvent(target.blindExpireTime, target);\r\n                    this.eventQueue.addEvent(blindExpirationEvent);\r\n                }\r\n\r\n                if (attackResult.didHit && abilityEffect.silenceChance > 0 && Math.random() < (abilityEffect.silenceChance * 100 / (100 + target.combatDetails.combatStats.tenacity))) {\r\n                    target.isSilenced = true;\r\n                    target.silenceExpireTime = this.simulationTime + abilityEffect.silenceDuration;\r\n                    this.eventQueue.clearMatching((event) => event.type == SilenceExpirationEvent.type && event.source == target)\r\n                    if (this.eventQueue.clearMatching((event) => event.type == AbilityCastEndEvent.type && event.source == target)) {\r\n                        // console.log(\"Silence \" + (this.simulationTime / 1000000000));\r\n                        this.addNextAttackEvent(target);\r\n                    }\r\n                    let silenceExpirationEvent = new SilenceExpirationEvent(target.silenceExpireTime, target);\r\n                    this.eventQueue.addEvent(silenceExpirationEvent);\r\n                }\r\n\r\n                if (attackResult.didHit && source.combatDetails.combatStats.curse > 0) {\r\n                    const curseExpireTime = 15000000000;\r\n                    let currentCurseEvent = this.eventQueue.getMatching((event) => event.type == CurseExpirationEvent.type && event.source == target);\r\n                    let currentCurseAmount = 0;\r\n                    if (currentCurseEvent) currentCurseAmount = currentCurseEvent.curseAmount;\r\n                    this.eventQueue.clearMatching((event) => event.type == CurseExpirationEvent.type && event.source == target);\r\n\r\n                    let curseExpirationEvent = new CurseExpirationEvent(this.simulationTime + curseExpireTime, currentCurseAmount, target);\r\n                    const curseBuff = {\r\n                        \"uniqueHrid\": \"/buff_uniques/curse\",\r\n                        \"typeHrid\": \"/buff_types/damage_taken\",\r\n                        \"ratioBoost\": 0,\r\n                        \"ratioBoostLevelBonus\": 0,\r\n                        \"flatBoost\": source.combatDetails.combatStats.curse * curseExpirationEvent.curseAmount,\r\n                        \"flatBoostLevelBonus\": 0,\r\n                        \"startTime\": \"0001-01-01T00:00:00Z\",\r\n                        \"duration\": curseExpireTime\r\n                    };\r\n                    target.addBuff(curseBuff, this.simulationTime);\r\n                    this.eventQueue.addEvent(curseExpirationEvent);\r\n                }\r\n\r\n                if (source.combatDetails.combatStats.fury > 0) {\r\n                    let currentFuryEvent = this.eventQueue.getMatching((event) => event.type == FuryExpirationEvent.type && event.source == source);\r\n                    this.eventQueue.clearMatching((event) => event.type == FuryExpirationEvent.type && event.source == source);\r\n\r\n                    const furyExpireTime = 15000000000;\r\n                    const maxFuryStack = 5;\r\n\r\n                    let furyAmount = 0;\r\n                    if (currentFuryEvent) furyAmount = currentFuryEvent.furyAmount;\r\n\r\n                    if (attackResult.didHit) {\r\n                        furyAmount = Math.min(furyAmount + 1, maxFuryStack);\r\n                    } else {\r\n                        furyAmount = furyAmount / 2;\r\n                    }\r\n\r\n                    const furyAccuracyBuf = {\r\n                        \"uniqueHrid\": \"/buff_uniques/fury_accuracy\",\r\n                        \"typeHrid\": \"/buff_types/fury_accuracy\",\r\n                        \"ratioBoost\": furyAmount * source.combatDetails.combatStats.fury,\r\n                        \"ratioBoostLevelBonus\": 0,\r\n                        \"flatBoost\": 0,\r\n                        \"flatBoostLevelBonus\": 0,\r\n                        \"startTime\": \"0001-01-01T00:00:00Z\",\r\n                        \"duration\": furyExpireTime\r\n                    };\r\n                    const furyDamageBuf = {\r\n                        \"uniqueHrid\": \"/buff_uniques/fury_damage\",\r\n                        \"typeHrid\": \"/buff_types/fury_damage\",\r\n                        \"ratioBoost\": furyAmount * source.combatDetails.combatStats.fury,\r\n                        \"ratioBoostLevelBonus\": 0,\r\n                        \"flatBoost\": 0,\r\n                        \"flatBoostLevelBonus\": 0,\r\n                        \"startTime\": \"0001-01-01T00:00:00Z\",\r\n                        \"duration\": furyExpireTime\r\n                    };\r\n\r\n                    if (furyAmount > 0) {\r\n                        let furyExpirationEvent = new FuryExpirationEvent(this.simulationTime + furyExpireTime, furyAmount, source);\r\n                        this.eventQueue.addEvent(furyExpirationEvent);\r\n\r\n                        source.addBuff(furyAccuracyBuf, this.simulationTime);\r\n                        source.addBuff(furyDamageBuf, this.simulationTime);\r\n                    }\r\n                    else {\r\n                        source.removeBuff(furyAccuracyBuf);\r\n                        source.removeBuff(furyDamageBuf);\r\n                    }\r\n                }\r\n\r\n                if (target.combatDetails.combatStats.weaken > 0) {\r\n                    const weakenExpireTime = 15000000000;\r\n                    source.weakenExpireTime = this.simulationTime + weakenExpireTime;\r\n                    let currentWeakenEvent = this.eventQueue.getMatching((event) => event.type == WeakenExpirationEvent.type && event.source == source);\r\n                    let weakenAmount = 0;\r\n                    if (currentWeakenEvent)\r\n                        weakenAmount = currentWeakenEvent.weakenAmount;\r\n                    this.eventQueue.clearMatching((event) => event.type == WeakenExpirationEvent.type && event.source == source);\r\n                    let weakenExpirationEvent = new WeakenExpirationEvent(this.simulationTime + weakenExpireTime, weakenAmount, source);\r\n                    const weakenBuff = {\r\n                        \"uniqueHrid\": \"/buff_uniques/weaken\",\r\n                        \"typeHrid\": \"/buff_types/damage\",\r\n                        \"ratioBoost\": -1 * target.combatDetails.combatStats.weaken * weakenExpirationEvent.weakenAmount,\r\n                        \"ratioBoostLevelBonus\": 0,\r\n                        \"flatBoost\": 0,\r\n                        \"flatBoostLevelBonus\": 0,\r\n                        \"startTime\": \"0001-01-01T00:00:00Z\",\r\n                        \"duration\": weakenExpireTime\r\n                    };\r\n                    source.addBuff(weakenBuff, this.simulationTime);\r\n                    this.eventQueue.addEvent(weakenExpirationEvent);\r\n                }\r\n\r\n                this.simResult.addAttack(\r\n                    source,\r\n                    target,\r\n                    ability.hrid,\r\n                    attackResult.didHit ? attackResult.damageDone : \"miss\"\r\n                );\r\n\r\n                if (attackResult.thornDamageDone > 0) {\r\n                    this.simResult.addAttack(target, source, attackResult.thornType, attackResult.thornDamageDone);\r\n                }\r\n                if (this.zone.isDungeon && attackResult.thornDamageDone > 0 && source.isPlayer) {\r\n                    const log = this.buildCombatLog(target, attackResult.thornType, source, attackResult.thornDamageDone);\r\n                    this.addToWipeLogs(log);\r\n                }\r\n\r\n                if (target.combatDetails.combatStats.retaliation > 0) {\r\n                    this.simResult.addAttack(target, source, \"retaliation\", attackResult.retaliationDamageDone > 0 ? attackResult.retaliationDamageDone : \"miss\");\r\n                }\r\n                if (this.zone.isDungeon && attackResult.retaliationDamageDone > 0 && source.isPlayer) {\r\n                    const log = this.buildCombatLog(target, \"retaliation\", source, attackResult.retaliationDamageDone);\r\n                    this.addToWipeLogs(log);\r\n                }\r\n\r\n                if (target.combatDetails.currentHitpoints == 0) {\r\n                    this.eventQueue.clearEventsForUnit(target);\r\n                    this.simResult.addDeath(target);\r\n                    if (!target.isPlayer) {\r\n                        this.simResult.updateTimeSpentAlive(target.hrid, false, this.simulationTime);\r\n                    }\r\n                    // console.log(target.hrid, \"died\");\r\n                }\r\n\r\n\r\n                if (attackResult.didHit && abilityEffect.pierceChance > Math.random()) {\r\n                    continue;\r\n                }\r\n            }\r\n            \r\n            if (parryTarget)\r\n            {\r\n                break;\r\n            }\r\n\r\n            if (abilityEffect.targetType == \"enemy\") {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    processAbilityHealEffect(source, ability, abilityEffect) {\r\n\r\n        if (abilityEffect.targetType == \"allAllies\") {\r\n            // targets may be null when there are no enemies; use empty array fallback to avoid exceptions\r\n            let targets = source.isPlayer ? this.players : (this.enemies || []);\r\n            for (const target of targets.filter((unit) => unit && unit.combatDetails.currentHitpoints > 0)) {\r\n                let amountHealed = CombatUtilities.processHeal(source, abilityEffect, target);\r\n\r\n                this.simResult.addHitpointsGained(target, ability.hrid, amountHealed);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (abilityEffect.targetType == \"lowestHpAlly\") {\r\n            // targets may be null when there are no enemies; use empty array fallback to avoid exceptions\r\n            let targets = source.isPlayer ? this.players : (this.enemies || []);\r\n            let healTarget;\r\n            for (const target of targets.filter((unit) => unit && unit.combatDetails.currentHitpoints > 0)) {\r\n                if (!healTarget) {\r\n                    healTarget = target;\r\n                    continue;\r\n                }\r\n                // 按HP百分比比较，选择百分比最低的目标\r\n                const targetHpPercent = target.combatDetails.currentHitpoints / target.combatDetails.maxHitpoints;\r\n                const healTargetHpPercent = healTarget.combatDetails.currentHitpoints / healTarget.combatDetails.maxHitpoints;\r\n                if (targetHpPercent < healTargetHpPercent) {\r\n                    healTarget = target;\r\n                }\r\n            }\r\n\r\n            if (healTarget) {\r\n                let amountHealed = CombatUtilities.processHeal(source, abilityEffect, healTarget);\r\n\r\n                this.simResult.addHitpointsGained(healTarget, ability.hrid, amountHealed);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (abilityEffect.targetType != \"self\") {\r\n            throw new Error(\"Unsupported target type for heal ability effect: \" + ability.hrid);\r\n        }\r\n\r\n        let amountHealed = CombatUtilities.processHeal(source, abilityEffect, source);\r\n\r\n        this.simResult.addHitpointsGained(source, ability.hrid, amountHealed);\r\n    }\r\n\r\n    processAbilityReviveEffect(source, ability, abilityEffect) {\r\n        if (abilityEffect.targetType != \"deadAlly\") {\r\n            throw new Error(\"Unsupported target type for revive ability effect: \" + ability.hrid);\r\n        }\r\n\r\n        // targets may be null when there are no enemies; use empty array fallback to avoid exceptions\r\n        let targets = source.isPlayer ? this.players : (this.enemies || []);\r\n        let reviveTarget = targets.find((unit) => unit && unit.combatDetails.currentHitpoints <= 0);\r\n\r\n        if (reviveTarget) {\r\n            this.eventQueue.clearMatching((event) => event.type == PlayerRespawnEvent.type && event.hrid == reviveTarget.hrid);\r\n\r\n            reviveTarget.removeExpiredBuffs(this.simulationTime);\r\n\r\n            let amountHealed = CombatUtilities.processRevive(source, abilityEffect, reviveTarget);\r\n\r\n            this.simResult.addHitpointsGained(reviveTarget, ability.hrid, amountHealed);\r\n\r\n            this.addNextAttackEvent(reviveTarget);\r\n\r\n            if (!source.isPlayer) {\r\n                this.simResult.updateTimeSpentAlive(reviveTarget.hrid, true, this.simulationTime);\r\n            }\r\n\r\n            // console.log(source.hrid + \" revived \" + reviveTarget.hrid + \" with \" + amountHealed + \" HP.\" + ' at wave #' + (this.zone.encountersKilled - 1) + ' at time ' + this.simulationTime / 1000000000 + 's');\r\n        }\r\n        return;\r\n    }\r\n\r\n    processAbilityPromoteEffect(source, ability, abilityEffect) {\r\n        const promotionHrids = [\"/monsters/enchanted_rook\", \"/monsters/enchanted_knight\", \"/monsters/enchanted_bishop\"];\r\n        let randomPromotionIndex = Math.floor(Math.random() * promotionHrids.length);\r\n        return new Monster(promotionHrids[randomPromotionIndex], source.difficultyTier, source.mazeDifficulty || 100, source.isMaze || false);\r\n    }\r\n\r\n    processAbilitySpendHpEffect(source, ability, abilityEffect) {\r\n        if (abilityEffect.targetType != \"self\") {\r\n            throw new Error(\"Unsupported target type for spend hp ability effect: \" + ability.hrid);\r\n        }\r\n\r\n        let hpSpent = CombatUtilities.processSpendHp(source, abilityEffect);\r\n\r\n        this.simResult.addHitpointsSpent(source, ability.hrid, hpSpent);\r\n    }\r\n}\r\n\r\nexport default CombatSimulator;\r\n","class CombatUnit {\r\n    isPlayer;\r\n    isMaze = false;\r\n    isStunned = false;\r\n    stunExpireTime = null;\r\n    isBlinded = false;\r\n    blindExpireTime = null;\r\n    isSilenced = false;\r\n    silenceExpireTime = null;\r\n\r\n    isOutOfMana = false;\r\n\r\n    // Base levels which don't change after initialization\r\n    staminaLevel = 1;\r\n    intelligenceLevel = 1;\r\n    attackLevel = 1;\r\n    meleeLevel = 1;\r\n    defenseLevel = 1;\r\n    rangedLevel = 1;\r\n    magicLevel = 1;\r\n\r\n    experience = 0;\r\n    experienceRate = 0;\r\n    enrageTime = 0;\r\n\r\n    abilities = [null, null, null, null];\r\n    food = [null, null, null];\r\n    drinks = [null, null, null];\r\n    houseRooms = [];\r\n    achievements = null;\r\n    dropTable = [];\r\n    rareDropTable = [];\r\n    abilityManaCosts = new Map();\r\n\r\n    // Calculated combat stats including temporary buffs\r\n    combatDetails = {\r\n        staminaLevel: 1,\r\n        intelligenceLevel: 1,\r\n        attackLevel: 1,\r\n        meleeLevel: 1,\r\n        defenseLevel: 1,\r\n        rangedLevel: 1,\r\n        magicLevel: 1,\r\n        maxHitpoints: 110,\r\n        currentHitpoints: 110,\r\n        maxManapoints: 110,\r\n        currentManapoints: 110,\r\n        stabAccuracyRating: 11,\r\n        slashAccuracyRating: 11,\r\n        smashAccuracyRating: 11,\r\n        rangedAccuracyRating: 11,\r\n        magicAccuracyRating: 11,\r\n        stabMaxDamage: 11,\r\n        slashMaxDamage: 11,\r\n        smashMaxDamage: 11,\r\n        rangedMaxDamage: 11,\r\n        magicMaxDamage: 11,\r\n        stabEvasionRating: 11,\r\n        slashEvasionRating: 11,\r\n        smashEvasionRating: 11,\r\n        rangedEvasionRating: 11,\r\n        magicEvasionRating: 11,\r\n        defensiveMaxDamage: 0,\r\n        totalArmor: 0.2,\r\n        totalWaterResistance: 0.4,\r\n        totalNatureResistance: 0.4,\r\n        totalFireResistance: 0.4,\r\n        abilityHaste: 0,\r\n        tenacity: 0,\r\n        totalThreat: 100,\r\n        combatStats: {\r\n            combatStyleHrid: \"/combat_styles/smash\",\r\n            damageType: \"/damage_types/physical\",\r\n            attackInterval: 3000000000,\r\n            autoAttackDamage: 0,\r\n            abilityDamage: 0,\r\n            criticalRate: 0,\r\n            criticalDamage: 0,\r\n            stabAccuracy: 0,\r\n            slashAccuracy: 0,\r\n            smashAccuracy: 0,\r\n            rangedAccuracy: 0,\r\n            magicAccuracy: 0,\r\n            stabDamage: 0,\r\n            slashDamage: 0,\r\n            smashDamage: 0,\r\n            rangedDamage: 0,\r\n            magicDamage: 0,\r\n            defensiveDamage: 0,\r\n            taskDamage: 0,\r\n            physicalAmplify: 0,\r\n            waterAmplify: 0,\r\n            natureAmplify: 0,\r\n            fireAmplify: 0,\r\n            healingAmplify: 0,\r\n            physicalThorns: 0,\r\n            elementalThorns: 0,\r\n            maxHitpoints: 0,\r\n            maxManapoints: 0,\r\n            stabEvasion: 0,\r\n            slashEvasion: 0,\r\n            smashEvasion: 0,\r\n            rangedEvasion: 0,\r\n            magicEvasion: 0,\r\n            armor: 0,\r\n            waterResistance: 0,\r\n            natureResistance: 0,\r\n            fireResistance: 0,\r\n            lifeSteal: 0,\r\n            hpRegenPer10: 0.01,\r\n            mpRegenPer10: 0.01,\r\n            combatDropRate: 0,\r\n            combatDropQuantity: 0,\r\n            combatRareFind: 0,\r\n            combatExperience: 0,\r\n            foodSlots: 1,\r\n            drinkSlots: 1,\r\n            armorPenetration: 0,\r\n            waterPenetration: 0,\r\n            naturePenetration: 0,\r\n            firePenetration: 0,\r\n            manaLeech: 0,\r\n            castSpeed: 0,\r\n            threat: 100,\r\n            parry: 0,\r\n            mayhem: 0,\r\n            pierce: 0,\r\n            curse: 0,\r\n            ripple: 0,\r\n            bloom: 0,\r\n            blaze: 0,\r\n            weaken: 0,\r\n            fury: 0,\r\n            foodHaste: 0,\r\n            drinkConcentration: 0,\r\n            damageTaken: 0,\r\n            attackSpeed: 0,\r\n            armorDamageRatio: 0,\r\n            hpDrainRatio: 0,\r\n            primaryTraining: \"\",\r\n            focusTraining: \"\",\r\n            staminaExperience: 0,\r\n            intelligenceExperience: 0,\r\n            attackExperience: 0,\r\n            defenseExperience: 0,\r\n            meleeExperience: 0,\r\n            rangedExperience: 0,\r\n            magicExperience: 0,\r\n            retaliation: 0,\r\n        },\r\n    };\r\n    combatBuffs = {};\r\n    permanentBuffs = {};\r\n    zoneBuffs = {};\r\n    extraBuffs = {};\r\n\r\n    constructor() { }\r\n\r\n    updateCombatDetails() {\r\n        if (this.isPlayer) {\r\n            if (this.combatDetails.combatStats.hpRegenPer10 === 0) {\r\n                this.combatDetails.combatStats.hpRegenPer10 = 0.01;\r\n            } else {\r\n                this.combatDetails.combatStats.hpRegenPer10 = 0.01 + this.combatDetails.combatStats.hpRegenPer10;\r\n            }\r\n            if (this.combatDetails.combatStats.mpRegenPer10 === 0) {\r\n                this.combatDetails.combatStats.mpRegenPer10 = 0.01;\r\n            } else {\r\n                this.combatDetails.combatStats.mpRegenPer10 = 0.01 + this.combatDetails.combatStats.mpRegenPer10;\r\n            }\r\n        }\r\n\r\n        [\"stamina\", \"intelligence\", \"attack\", \"melee\", \"defense\", \"ranged\", \"magic\"].forEach((stat) => {\r\n            this.combatDetails[stat + \"Level\"] = this[stat + \"Level\"];\r\n            let boosts = this.getBuffBoosts(\"/buff_types/\" + stat + \"_level\");\r\n            boosts.forEach((buff) => {\r\n                this.combatDetails[stat + \"Level\"] += (this[stat + \"Level\"] * buff.ratioBoost);\r\n                this.combatDetails[stat + \"Level\"] += buff.flatBoost;\r\n            });\r\n        });\r\n\r\n        // Maze mode grants flat +15 to several combat levels\r\n        if (this.isMaze && this.isPlayer) {\r\n            [\"stamina\", \"intelligence\", \"attack\", \"defense\", \"magic\", \"ranged\", \"melee\"].forEach((stat) => {\r\n                this.combatDetails[stat + \"Level\"] += 15;\r\n            });\r\n        }\r\n\r\n        this.combatDetails.maxHitpoints = Math.floor\r\n            (10 * (10 + this.combatDetails.staminaLevel) + this.combatDetails.combatStats.maxHitpoints);\r\n        this.combatDetails.maxManapoints = Math.floor\r\n            (10 * (10 + this.combatDetails.intelligenceLevel) + this.combatDetails.combatStats.maxManapoints);\r\n\r\n        let accuracyRatioBoostFromFury = this.getBuffBoost(\"/buff_types/fury_accuracy\").ratioBoost;\r\n        let damageRatioBoostFromFury = this.getBuffBoost(\"/buff_types/fury_damage\").ratioBoost;\r\n        // if (accuracyRatioBoostFromFury > 0) {\r\n        //     console.log(\"Fury Boost: \" + accuracyRatioBoostFromFury);\r\n        // }\r\n\r\n        let accuracyRatioBoost = this.getBuffBoost(\"/buff_types/accuracy\").ratioBoost;\r\n        let damageRatioBoost = this.getBuffBoost(\"/buff_types/damage\").ratioBoost;\r\n\r\n        [\"stab\", \"slash\", \"smash\"].forEach((style) => {\r\n            this.combatDetails[style + \"AccuracyRating\"] =\r\n                (10 + this.combatDetails.attackLevel) *\r\n                (1 + this.combatDetails.combatStats[style + \"Accuracy\"]) *\r\n                (1 + accuracyRatioBoost) *\r\n                (1 + accuracyRatioBoostFromFury);\r\n            this.combatDetails[style + \"MaxDamage\"] =\r\n                (10 + this.combatDetails.meleeLevel) *\r\n                (1 + this.combatDetails.combatStats[style + \"Damage\"]) *\r\n                (1 + damageRatioBoost) *\r\n                (1 + damageRatioBoostFromFury);\r\n            let baseEvasion = (10 + this.combatDetails.defenseLevel) * (1 + this.combatDetails.combatStats[style + \"Evasion\"]);\r\n            this.combatDetails[style + \"EvasionRating\"] = baseEvasion;\r\n            let evasionBoosts = this.getBuffBoosts(\"/buff_types/evasion\");\r\n            for (const boost of evasionBoosts) {\r\n                this.combatDetails[style + \"EvasionRating\"] += boost.flatBoost;\r\n                this.combatDetails[style + \"EvasionRating\"] += baseEvasion * boost.ratioBoost;\r\n            }\r\n        });\r\n\r\n        this.combatDetails.defensiveMaxDamage = \r\n            (10 + this.combatDetails.defenseLevel) * \r\n            (1 + this.combatDetails.combatStats.defensiveDamage) *\r\n            (1 + damageRatioBoost) *\r\n            (1 + damageRatioBoostFromFury);\r\n\r\n        // when equiped bulwark\r\n        if (this.equipment?.['/equipment_types/two_hand']?.hrid.includes(\"bulwark\")) {\r\n            this.combatDetails.smashMaxDamage += this.combatDetails.defensiveMaxDamage;\r\n        }\r\n\r\n        this.combatDetails.rangedAccuracyRating =\r\n            (10 + this.combatDetails.attackLevel) *\r\n            (1 + this.combatDetails.combatStats.rangedAccuracy) *\r\n            (1 + accuracyRatioBoost) *\r\n            (1 + accuracyRatioBoostFromFury);\r\n        this.combatDetails.rangedMaxDamage =\r\n            (10 + this.combatDetails.rangedLevel) *\r\n            (1 + this.combatDetails.combatStats.rangedDamage) *\r\n            (1 + damageRatioBoost) *\r\n            (1 + damageRatioBoostFromFury);\r\n\r\n        let baseRangedEvasion = (10 + this.combatDetails.defenseLevel) * (1 + this.combatDetails.combatStats.rangedEvasion);\r\n        this.combatDetails.rangedEvasionRating = baseRangedEvasion;\r\n        let evasionBoosts = this.getBuffBoosts(\"/buff_types/evasion\");\r\n        for (const boost of evasionBoosts) {\r\n            this.combatDetails.rangedEvasionRating += boost.flatBoost;\r\n            this.combatDetails.rangedEvasionRating += baseRangedEvasion * boost.ratioBoost;\r\n        }\r\n\r\n        this.combatDetails.combatStats.damageTaken = this.getBuffBoost(\"/buff_types/damage_taken\").flatBoost;\r\n        // if (this.combatDetails.combatStats.damageTaken > 0) {\r\n        //     console.log(\"Damage taken: \" + this.combatDetails.combatStats.damageTaken);\r\n        // }\r\n\r\n        this.combatDetails.magicAccuracyRating =\r\n            (10 + this.combatDetails.attackLevel) *\r\n            (1 + this.combatDetails.combatStats.magicAccuracy) *\r\n            (1 + accuracyRatioBoost) *\r\n            (1 + accuracyRatioBoostFromFury);\r\n        this.combatDetails.magicMaxDamage =\r\n            (10 + this.combatDetails.magicLevel) *\r\n            (1 + this.combatDetails.combatStats.magicDamage) *\r\n            (1 + damageRatioBoost) *\r\n            (1 + damageRatioBoostFromFury);\r\n\r\n        let baseMagicEvasion = (10 + this.combatDetails.defenseLevel) * (1 + this.combatDetails.combatStats.magicEvasion);\r\n        this.combatDetails.magicEvasionRating = baseMagicEvasion;\r\n        for (const boost of evasionBoosts) {\r\n            this.combatDetails.magicEvasionRating += boost.flatBoost;\r\n            this.combatDetails.magicEvasionRating += baseMagicEvasion * boost.ratioBoost;\r\n        }\r\n\r\n        this.combatDetails.combatStats.physicalAmplify += this.getBuffBoost(\"/buff_types/physical_amplify\").flatBoost;\r\n        this.combatDetails.combatStats.waterAmplify += this.getBuffBoost(\"/buff_types/water_amplify\").flatBoost;\r\n        this.combatDetails.combatStats.natureAmplify += this.getBuffBoost(\"/buff_types/nature_amplify\").flatBoost;\r\n        this.combatDetails.combatStats.fireAmplify += this.getBuffBoost(\"/buff_types/fire_amplify\").flatBoost;\r\n        this.combatDetails.combatStats.healingAmplify += this.getBuffBoost(\"/buff_types/healing_amplify\").flatBoost;\r\n\r\n        this.combatDetails.combatStats.attackInterval /= (1 + (this.combatDetails.attackLevel / 2000));\r\n\r\n        let baseAttackSpeed = this.combatDetails.combatStats.attackSpeed;\r\n        if (this.isMaze && this.isPlayer) {\r\n            // +15% attack speed in maze\r\n            this.combatDetails.combatStats.attackSpeed += 0.15;\r\n            baseAttackSpeed = this.combatDetails.combatStats.attackSpeed;\r\n        }\r\n        this.combatDetails.combatStats.attackInterval /= (1 + baseAttackSpeed);\r\n        let attackIntervalBoosts = this.getBuffBoosts(\"/buff_types/attack_speed\");\r\n        let attackIntervalRatioBoost = attackIntervalBoosts\r\n            .map((boost) => boost.ratioBoost)\r\n            .reduce((prev, cur) => prev + cur, 0);\r\n        this.combatDetails.combatStats.attackInterval /= (1 + attackIntervalRatioBoost);\r\n\r\n        let baseArmor = 0.2 * this.combatDetails.defenseLevel + this.combatDetails.combatStats.armor;\r\n        this.combatDetails.totalArmor = baseArmor;\r\n        let armorBoosts = this.getBuffBoosts(\"/buff_types/armor\");\r\n        for (const boost of armorBoosts) {\r\n            this.combatDetails.totalArmor += boost.flatBoost;\r\n            this.combatDetails.totalArmor += baseArmor * boost.ratioBoost;\r\n        }\r\n\r\n        let baseWaterResistance =\r\n            0.2 * this.combatDetails.defenseLevel +\r\n            this.combatDetails.combatStats.waterResistance;\r\n        this.combatDetails.totalWaterResistance = baseWaterResistance;\r\n        let waterResistanceBoosts = this.getBuffBoosts(\"/buff_types/water_resistance\");\r\n        for (const boost of waterResistanceBoosts) {\r\n            this.combatDetails.totalWaterResistance += boost.flatBoost;\r\n            this.combatDetails.totalWaterResistance += baseWaterResistance * boost.ratioBoost;\r\n        }\r\n\r\n        let baseNatureResistance =\r\n            0.2 * this.combatDetails.defenseLevel +\r\n            this.combatDetails.combatStats.natureResistance;\r\n        this.combatDetails.totalNatureResistance = baseNatureResistance;\r\n        let natureResistanceBoosts = this.getBuffBoosts(\"/buff_types/nature_resistance\");\r\n        for (const boost of natureResistanceBoosts) {\r\n            this.combatDetails.totalNatureResistance += boost.flatBoost;\r\n            this.combatDetails.totalNatureResistance += baseNatureResistance * boost.ratioBoost;\r\n        }\r\n\r\n        let baseFireResistance =\r\n            0.2 * this.combatDetails.defenseLevel +\r\n            this.combatDetails.combatStats.fireResistance;\r\n        this.combatDetails.totalFireResistance = baseFireResistance;\r\n        let fireResistanceBoosts = this.getBuffBoosts(\"/buff_types/fire_resistance\");\r\n        for (const boost of fireResistanceBoosts) {\r\n            this.combatDetails.totalFireResistance += boost.flatBoost;\r\n            this.combatDetails.totalFireResistance += baseFireResistance * boost.ratioBoost;\r\n        }\r\n\r\n        let hpRegenBoosts = this.getBuffBoost(\"/buff_types/hp_regen\");\r\n        this.combatDetails.combatStats.hpRegenPer10 += this.combatDetails.combatStats.hpRegenPer10 * hpRegenBoosts.ratioBoost;\r\n        this.combatDetails.combatStats.hpRegenPer10 += hpRegenBoosts.flatBoost;\r\n\r\n        let mpRegenBoosts = this.getBuffBoost(\"/buff_types/mp_regen\");\r\n        this.combatDetails.combatStats.mpRegenPer10 += this.combatDetails.combatStats.mpRegenPer10 * mpRegenBoosts.ratioBoost;\r\n        this.combatDetails.combatStats.mpRegenPer10 += mpRegenBoosts.flatBoost;\r\n\r\n        if (this.isMaze && this.isPlayer) {\r\n            // +6% HP/MP regen in maze\r\n            this.combatDetails.combatStats.hpRegenPer10 += this.combatDetails.combatStats.hpRegenPer10 + 0.06;\r\n            this.combatDetails.combatStats.mpRegenPer10 += this.combatDetails.combatStats.mpRegenPer10 + 0.06;\r\n        }\r\n\r\n        this.combatDetails.combatStats.lifeSteal += this.getBuffBoost(\"/buff_types/life_steal\").flatBoost;\r\n        this.combatDetails.combatStats.physicalThorns += this.getBuffBoost(\r\n            \"/buff_types/physical_thorns\"\r\n        ).flatBoost;\r\n        this.combatDetails.combatStats.elementalThorns += this.getBuffBoost(\r\n            \"/buff_types/elemental_thorns\"\r\n        ).flatBoost;\r\n        this.combatDetails.combatStats.combatExperience += this.getBuffBoost(\"/buff_types/wisdom\").flatBoost;\r\n        this.combatDetails.combatStats.criticalRate += this.getBuffBoost(\"/buff_types/critical_rate\").flatBoost;\r\n        this.combatDetails.combatStats.criticalDamage += this.getBuffBoost(\"/buff_types/critical_damage\").flatBoost;\r\n        if (this.isMaze && this.isPlayer) {\r\n            // +6% critical rate, +10% critical damage, +15% combat experience in maze\r\n            this.combatDetails.combatStats.criticalRate += 0.06;\r\n            this.combatDetails.combatStats.criticalDamage += 0.10;\r\n            this.combatDetails.combatStats.combatExperience += 0.15;\r\n        }\r\n\r\n        this.combatDetails.combatStats.castSpeed += this.getBuffBoost(\"/buff_types/cast_speed\").flatBoost;\r\n        this.combatDetails.combatStats.castSpeed += this.combatDetails[\"attackLevel\"] / 2000;\r\n        if (this.isMaze && this.isPlayer) {\r\n            // +15% cast speed in maze\r\n            this.combatDetails.combatStats.castSpeed += 0.15;\r\n        }\r\n\r\n        let combatDropRateBoosts = this.getBuffBoost(\"/buff_types/combat_drop_rate\");\r\n        this.combatDetails.combatStats.combatDropRate += (1 + this.combatDetails.combatStats.combatDropRate) * combatDropRateBoosts.ratioBoost;\r\n        this.combatDetails.combatStats.combatDropRate += combatDropRateBoosts.flatBoost;\r\n        let combatRareFindBoosts = this.getBuffBoost(\"/buff_types/rare_find\");\r\n        this.combatDetails.combatStats.combatRareFind += (1 + this.combatDetails.combatStats.combatRareFind) * combatRareFindBoosts.ratioBoost;\r\n        this.combatDetails.combatStats.combatRareFind += combatRareFindBoosts.flatBoost;\r\n        let combatDropQuantityBoosts = this.getBuffBoost(\"/buff_types/combat_drop_quantity\");\r\n        this.combatDetails.combatStats.combatDropQuantity += (1 + this.combatDetails.combatStats.combatDropQuantity) * combatDropQuantityBoosts.ratioBoost;\r\n        this.combatDetails.combatStats.combatDropQuantity += combatDropQuantityBoosts.flatBoost;\r\n\r\n        let baseThreat = 100 + this.combatDetails.combatStats.threat;\r\n        this.combatDetails.totalThreat = baseThreat;\r\n        let threatBoosts = this.getBuffBoost(\"/buff_types/threat\");\r\n        if (threatBoosts.ratioBoost !== 0) {\r\n            this.combatDetails.combatStats.threat += baseThreat * threatBoosts.ratioBoost;\r\n        } else {\r\n            this.combatDetails.combatStats.threat = baseThreat;\r\n        }\r\n        this.combatDetails.combatStats.threat += threatBoosts.flatBoost;\r\n\r\n        this.combatDetails.combatStats.retaliation += this.getBuffBoost(\"/buff_types/retaliation\").flatBoost;\r\n        this.combatDetails.combatStats.tenacity += this.getBuffBoost(\"/buff_types/tenacity\").flatBoost;\r\n    }\r\n\r\n    addBuff(buff, currentTime) {\r\n        buff.startTime = currentTime;\r\n        this.combatBuffs[buff.uniqueHrid] = buff;\r\n\r\n        this.updateCombatDetails();\r\n    }\r\n\r\n    removeBuff(buff) {\r\n        if (!this.combatBuffs[buff.uniqueHrid]) {\r\n            return;\r\n        }\r\n        delete this.combatBuffs[buff.uniqueHrid];\r\n\r\n        this.updateCombatDetails();\r\n    }\r\n\r\n    addPermanentBuff(buff) {\r\n        if (this.permanentBuffs[buff.typeHrid]) {\r\n            this.permanentBuffs[buff.typeHrid].flatBoost += buff.flatBoost;\r\n            this.permanentBuffs[buff.typeHrid].ratioBoost += buff.ratioBoost;\r\n        } else {\r\n            this.permanentBuffs[buff.typeHrid] = buff;\r\n        }\r\n    }\r\n\r\n    generatePermanentBuffs() {\r\n        for (let i = 0; i < this.houseRooms.length; i++) {\r\n            const houseRoom = this.houseRooms[i];\r\n            houseRoom.buffs.forEach(buff => {\r\n                this.addPermanentBuff(buff);\r\n            });\r\n        }\r\n\r\n        if (this.achievements) {\r\n            this.achievements.buffs.forEach(buff => {\r\n                this.addPermanentBuff(buff);\r\n            });\r\n        }\r\n        if (this.zoneBuffs) {\r\n            this.zoneBuffs.forEach(buff => {\r\n                this.addPermanentBuff(buff);\r\n            });\r\n        }\r\n        if (this.extraBuffs) {\r\n            this.extraBuffs.forEach(buff => {\r\n                this.addPermanentBuff(buff);\r\n            });\r\n        }\r\n    }\r\n\r\n    removeExpiredBuffs(currentTime) {\r\n        let expiredBuffs = Object.values(this.combatBuffs).filter(\r\n            (buff) => buff.startTime + buff.duration <= currentTime\r\n        );\r\n        expiredBuffs.forEach((buff) => {\r\n            delete this.combatBuffs[buff.uniqueHrid];\r\n        });\r\n\r\n        this.updateCombatDetails();\r\n    }\r\n\r\n    clearBuffs() {\r\n        this.combatBuffs = structuredClone(this.permanentBuffs);\r\n        this.updateCombatDetails();\r\n    }\r\n\r\n    clearCCs() {\r\n        this.isStunned = false;\r\n        this.stunExpireTime = null;\r\n        this.isSilenced = false;\r\n        this.silenceExpireTime = null;\r\n        this.isBlinded = false;\r\n        this.blindExpireTime = null;\r\n        this.combatDetails.combatStats.damageTaken = 0;\r\n    }\r\n\r\n    getBuffBoosts(type) {\r\n        let boosts = [];\r\n        Object.values(this.combatBuffs)\r\n            .filter((buff) => buff.typeHrid == type)\r\n            .forEach((buff) => {\r\n                boosts.push({ ratioBoost: buff.ratioBoost, flatBoost: buff.flatBoost });\r\n            });\r\n\r\n        return boosts;\r\n    }\r\n\r\n    getBuffBoost(type) {\r\n        let boosts = this.getBuffBoosts(type);\r\n\r\n        let boost = {\r\n            ratioBoost: 0,\r\n            flatBoost: 0,\r\n        };\r\n\r\n        for (let i = 0; i < boosts.length; i++) {\r\n            boost.ratioBoost += boosts[i]?.ratioBoost ?? 0;\r\n            boost.flatBoost += boosts[i]?.flatBoost ?? 0;\r\n        }\r\n\r\n        return boost;\r\n    }\r\n\r\n    reset(currentTime = 0) {\r\n        this.clearCCs();\r\n        \r\n        // 只有玩家在地下城团灭重开时保留buff和CD，敌人始终完全重置\r\n        if (currentTime == 0 || !this.isPlayer) {\r\n            // 首次战斗开始 或 敌人重置：完全重置\r\n            this.clearBuffs();\r\n            this.updateCombatDetails();\r\n            this.resetCooldowns(currentTime);\r\n        } else {\r\n            // 地下城团灭重开（仅玩家）：只移除过期buff，保留CD\r\n            this.removeExpiredBuffs(currentTime);\r\n            this.updateCombatDetails();\r\n        }\r\n\r\n        this.combatDetails.currentHitpoints = this.combatDetails.maxHitpoints;\r\n        this.combatDetails.currentManapoints = this.combatDetails.maxManapoints;\r\n    }\r\n\r\n    resetCooldowns(currentTime = 0) {\r\n        this.food.filter((food) => food != null).forEach((food) => (food.lastUsed = Number.MIN_SAFE_INTEGER));\r\n        this.drinks.filter((drink) => drink != null).forEach((drink) => (drink.lastUsed = Number.MIN_SAFE_INTEGER));\r\n\r\n        let haste = this.combatDetails.combatStats.abilityHaste;\r\n\r\n        this.abilities\r\n            .filter((ability) => ability != null)\r\n            .forEach((ability) => {\r\n                if (this.isPlayer) {\r\n                    ability.lastUsed = Number.MIN_SAFE_INTEGER;\r\n                } else {\r\n                    let cooldownDuration = ability.cooldownDuration;\r\n                    if (haste > 0) {\r\n                        cooldownDuration = cooldownDuration * 100 / (100 + haste);\r\n                    }\r\n                    ability.lastUsed = currentTime - Math.floor(cooldownDuration * 0.5) + Math.floor(Math.random() * cooldownDuration * 0.5);\r\n                }\r\n            });\r\n    }\r\n\r\n    addHitpoints(hitpoints) {\r\n        let hitpointsAdded = 0;\r\n\r\n        if (this.combatDetails.currentHitpoints >= this.combatDetails.maxHitpoints) {\r\n            return hitpointsAdded;\r\n        }\r\n\r\n        let newHitpoints = Math.min(this.combatDetails.currentHitpoints + hitpoints, this.combatDetails.maxHitpoints);\r\n        hitpointsAdded = newHitpoints - this.combatDetails.currentHitpoints;\r\n        this.combatDetails.currentHitpoints = newHitpoints;\r\n\r\n        return hitpointsAdded;\r\n    }\r\n\r\n    addManapoints(manapoints) {\r\n        let manapointsAdded = 0;\r\n\r\n        if (this.combatDetails.currentManapoints >= this.combatDetails.maxManapoints) {\r\n            return manapointsAdded;\r\n        }\r\n\r\n        let newManapoints = Math.min(\r\n            this.combatDetails.currentManapoints + manapoints,\r\n            this.combatDetails.maxManapoints\r\n        );\r\n        manapointsAdded = newManapoints - this.combatDetails.currentManapoints;\r\n        this.combatDetails.currentManapoints = newManapoints;\r\n\r\n        return manapointsAdded;\r\n    }\r\n}\r\n\r\nexport default CombatUnit;\r\n","class CombatUtilities {\r\n    static getTarget(enemies) {\r\n        if (!enemies) {\r\n            return null;\r\n        }\r\n        let target = enemies.find((enemy) => enemy.combatDetails.currentHitpoints > 0);\r\n\r\n        return target ?? null;\r\n    }\r\n\r\n    static randomInt(min, max) {\r\n        if (max < min) {\r\n            let temp = min;\r\n            min = max;\r\n            max = temp;\r\n        }\r\n\r\n        let minCeil = Math.ceil(min);\r\n        let maxFloor = Math.floor(max);\r\n\r\n        if (Math.floor(min) == maxFloor) {\r\n            return Math.floor((min + max) / 2 + Math.random());\r\n        }\r\n\r\n        let minTail = -1 * (min - minCeil);\r\n        let maxTail = max - maxFloor;\r\n\r\n        let balancedWeight = 2 * minTail + (maxFloor - minCeil);\r\n        let balancedAverage = (maxFloor + minCeil) / 2;\r\n        let average = (max + min) / 2;\r\n        let extraTailWeight = (balancedWeight * (average - balancedAverage)) / (maxFloor + 1 - average);\r\n        let extraTailChance = Math.abs(extraTailWeight / (extraTailWeight + balancedWeight));\r\n\r\n        if (Math.random() < extraTailChance) {\r\n            if (maxTail > minTail) {\r\n                return Math.floor(maxFloor + 1);\r\n            } else {\r\n                return Math.floor(minCeil - 1);\r\n            }\r\n        }\r\n\r\n        if (maxTail > minTail) {\r\n            return Math.floor(min + Math.random() * (maxFloor + minTail - min + 1));\r\n        } else {\r\n            return Math.floor(minCeil - maxTail + Math.random() * (max - (minCeil - maxTail) + 1));\r\n        }\r\n    }\r\n\r\n    static processAttack(source, target, abilityEffect = null, options = null) {\r\n        let combatStyle = abilityEffect\r\n            ? abilityEffect.combatStyleHrid\r\n            : source.combatDetails.combatStats.combatStyleHrid;\r\n        let damageType = abilityEffect ? abilityEffect.damageType : source.combatDetails.combatStats.damageType;\r\n\r\n        let sourceAccuracyRating = 1;\r\n        let sourceAutoAttackMaxDamage = 1;\r\n        let targetEvasionRating = 1;\r\n\r\n        switch (combatStyle) {\r\n            case \"/combat_styles/stab\":\r\n                sourceAccuracyRating = source.combatDetails.stabAccuracyRating;\r\n                sourceAutoAttackMaxDamage = source.combatDetails.stabMaxDamage;\r\n                targetEvasionRating = target.combatDetails.stabEvasionRating;\r\n                break;\r\n            case \"/combat_styles/slash\":\r\n                sourceAccuracyRating = source.combatDetails.slashAccuracyRating;\r\n                sourceAutoAttackMaxDamage = source.combatDetails.slashMaxDamage;\r\n                targetEvasionRating = target.combatDetails.slashEvasionRating;\r\n                break;\r\n            case \"/combat_styles/smash\":\r\n                sourceAccuracyRating = source.combatDetails.smashAccuracyRating;\r\n                sourceAutoAttackMaxDamage = source.combatDetails.smashMaxDamage;\r\n                targetEvasionRating = target.combatDetails.smashEvasionRating;\r\n                break;\r\n            case \"/combat_styles/ranged\":\r\n                sourceAccuracyRating = source.combatDetails.rangedAccuracyRating;\r\n                sourceAutoAttackMaxDamage = source.combatDetails.rangedMaxDamage;\r\n                targetEvasionRating = target.combatDetails.rangedEvasionRating;\r\n                break;\r\n            case \"/combat_styles/magic\":\r\n                sourceAccuracyRating = source.combatDetails.magicAccuracyRating;\r\n                sourceAutoAttackMaxDamage = source.combatDetails.magicMaxDamage;\r\n                targetEvasionRating = target.combatDetails.magicEvasionRating;\r\n                break;\r\n            default:\r\n                throw new Error(\"Unknown combat style: \" + combatStyle);\r\n        }\r\n\r\n        let sourceDamageMultiplier = 1;\r\n        let sourceResistance = 0;\r\n        let sourcePenetration = 0;\r\n        let targetResistance = 0;\r\n        let targetThornPower = 0;\r\n        let targetPenetration = 0;\r\n        let thornType;\r\n\r\n        switch (damageType) {\r\n            case \"/damage_types/physical\":\r\n                sourceDamageMultiplier = 1 + source.combatDetails.combatStats.physicalAmplify;\r\n                sourceResistance = source.combatDetails.totalArmor;\r\n                sourcePenetration = source.combatDetails.combatStats.armorPenetration;\r\n                targetResistance = target.combatDetails.totalArmor;\r\n                targetThornPower = target.combatDetails.combatStats.physicalThorns;\r\n                targetPenetration = target.combatDetails.combatStats.armorPenetration;\r\n                thornType = \"physicalThorns\";\r\n                break;\r\n            case \"/damage_types/water\":\r\n                sourceDamageMultiplier = 1 + source.combatDetails.combatStats.waterAmplify;\r\n                sourceResistance = source.combatDetails.totalWaterResistance;\r\n                sourcePenetration = source.combatDetails.combatStats.waterPenetration;\r\n                targetResistance = target.combatDetails.totalWaterResistance;\r\n                targetThornPower = target.combatDetails.combatStats.elementalThorns;\r\n                targetPenetration = target.combatDetails.combatStats.waterPenetration;\r\n                thornType = \"elementalThorns\";\r\n                break;\r\n            case \"/damage_types/nature\":\r\n                sourceDamageMultiplier = 1 + source.combatDetails.combatStats.natureAmplify;\r\n                sourceResistance = source.combatDetails.totalNatureResistance;\r\n                sourcePenetration = source.combatDetails.combatStats.naturePenetration;\r\n                targetResistance = target.combatDetails.totalNatureResistance;\r\n                targetThornPower = target.combatDetails.combatStats.elementalThorns;\r\n                targetPenetration = target.combatDetails.combatStats.naturePenetration;\r\n                thornType = \"elementalThorns\";\r\n                break;\r\n            case \"/damage_types/fire\":\r\n                sourceDamageMultiplier = 1 + source.combatDetails.combatStats.fireAmplify;\r\n                sourceResistance = source.combatDetails.totalFireResistance;\r\n                sourcePenetration = source.combatDetails.combatStats.firePenetration;\r\n                targetResistance = target.combatDetails.totalFireResistance;\r\n                targetThornPower = target.combatDetails.combatStats.elementalThorns;\r\n                targetPenetration = target.combatDetails.combatStats.firePenetration;\r\n                thornType = \"elementalThorns\";\r\n                break;\r\n            default:\r\n                throw new Error(\"Unknown damage type: \" + damageType);\r\n        }\r\n\r\n        let hitChance = 1;\r\n        let critChance = 0;\r\n        let isCrit = false;\r\n        let bonusCritChance = source.combatDetails.combatStats.criticalRate;\r\n        let bonusCritDamage = source.combatDetails.combatStats.criticalDamage;\r\n\r\n        if (abilityEffect) {\r\n            sourceAccuracyRating *= (1 + abilityEffect.bonusAccuracyRatio);\r\n        }\r\n\r\n        if (source.isWeakened) {\r\n            sourceAccuracyRating = sourceAccuracyRating - (source.weakenPercentage * sourceAccuracyRating);\r\n        }\r\n\r\n        hitChance =\r\n            Math.pow(sourceAccuracyRating, 1.4) /\r\n            (Math.pow(sourceAccuracyRating, 1.4) + Math.pow(targetEvasionRating, 1.4));\r\n\r\n        if (combatStyle == \"/combat_styles/ranged\") {\r\n            critChance = 0.3 * hitChance;\r\n        }\r\n\r\n        critChance = critChance + bonusCritChance;\r\n\r\n        let baseDamageFlat = abilityEffect ? abilityEffect.damageFlat : 0;\r\n        let baseDamageRatio = abilityEffect ? abilityEffect.damageRatio : 1;\r\n\r\n        let armorDamageRatioFlat = abilityEffect ? abilityEffect.armorDamageRatio * source.combatDetails.totalArmor : 0;\r\n\r\n        let sourceMinDamage = sourceDamageMultiplier * (1 + baseDamageFlat + armorDamageRatioFlat);\r\n        let sourceMaxDamage = sourceDamageMultiplier * (baseDamageRatio * sourceAutoAttackMaxDamage + baseDamageFlat + armorDamageRatioFlat);\r\n\r\n        if (Math.random() < critChance) {\r\n            sourceMaxDamage = sourceMaxDamage * (1 + bonusCritDamage);\r\n            sourceMinDamage = sourceMaxDamage;\r\n            isCrit = true;\r\n        }\r\n\r\n        let damageRoll = CombatUtilities.randomInt(sourceMinDamage, sourceMaxDamage);\r\n        damageRoll *= (1 + source.combatDetails.combatStats.taskDamage);\r\n        damageRoll *= (1 + target.combatDetails.combatStats.damageTaken);\r\n        if (!abilityEffect) {\r\n            damageRoll += damageRoll * source.combatDetails.combatStats.autoAttackDamage;\r\n        } else {\r\n            damageRoll *= (1 + source.combatDetails.combatStats.abilityDamage);\r\n        }\r\n\r\n        let damageDone = 0;\r\n        let thornDamageDone = 0;\r\n\r\n        let didHit = false;\r\n        \r\n        const forceKill = options && options.mazeInstantKill && !source.isPlayer && target.isPlayer;\r\n        if (forceKill) {\r\n            didHit = true;\r\n            damageDone = target.combatDetails.currentHitpoints;\r\n            target.combatDetails.currentHitpoints -= damageDone;\r\n        }\r\n        else if (Math.random() < hitChance) {\r\n            didHit = true;\r\n            let penetratedTargetResistance = targetResistance;\r\n\r\n            if (sourcePenetration > 0 && targetResistance > 0) {\r\n                penetratedTargetResistance = targetResistance / (1 + sourcePenetration);\r\n            }\r\n\r\n            let targetDamageTakenRatio = 100 / (100 + penetratedTargetResistance);\r\n            if (penetratedTargetResistance < 0) {\r\n                targetDamageTakenRatio = (100 - penetratedTargetResistance) / 100;\r\n            }\r\n\r\n            let mitigatedDamage = Math.ceil(targetDamageTakenRatio * damageRoll);\r\n            damageDone = Math.min(mitigatedDamage, target.combatDetails.currentHitpoints);\r\n            target.combatDetails.currentHitpoints -= damageDone;\r\n        }\r\n\r\n        if (targetThornPower > 0.0 && targetResistance > -99.0) {\r\n            let penetratedSourceResistance = sourceResistance\r\n\r\n            if (sourceResistance > 0) {\r\n                penetratedSourceResistance = sourceResistance / (1 + targetPenetration);\r\n            }\r\n\r\n            let sourceDamageTakenRatio = 100.0 / (100 + penetratedSourceResistance);\r\n            if (penetratedSourceResistance < 0) {\r\n                sourceDamageTakenRatio = (100 - penetratedSourceResistance) / 100;\r\n            }\r\n\r\n            let targetTaskDamageMultiplier = 1.0 + target.combatDetails.combatStats.taskDamage;\r\n            let sourceDamageTakenMultiplier = 1.0 + source.combatDetails.combatStats.damageTaken;\r\n            let targetDamageMultiplier = targetTaskDamageMultiplier * sourceDamageTakenMultiplier;\r\n\r\n            let thornsDamageRoll = CombatUtilities.randomInt(1,\r\n                targetDamageMultiplier\r\n                * target.combatDetails.defensiveMaxDamage\r\n                * (1.0 + targetResistance / 100.0)\r\n                * targetThornPower);\r\n\r\n            let mitigatedThornsDamage = Math.ceil(sourceDamageTakenRatio * thornsDamageRoll);\r\n\r\n            thornDamageDone = Math.min(mitigatedThornsDamage, source.combatDetails.currentHitpoints);\r\n            source.combatDetails.currentHitpoints -= thornDamageDone;\r\n        }\r\n\r\n        let retaliationDamageDone = 0;\r\n        if (target.combatDetails.combatStats.retaliation > 0) {\r\n            let retaliationHitChance = \r\n                Math.pow(target.combatDetails.smashAccuracyRating, 1.4) /\r\n                (Math.pow(target.combatDetails.smashAccuracyRating, 1.4) + Math.pow(source.combatDetails.smashEvasionRating, 1.4));\r\n\r\n            if (retaliationHitChance > Math.random()) {\r\n                let sourceEffectiveArmor = source.combatDetails.totalArmor;\r\n                if (sourceEffectiveArmor > 0) {\r\n                    sourceEffectiveArmor = sourceEffectiveArmor / (1.0 + target.combatDetails.combatStats.armorPenetration);\r\n                }\r\n\r\n                let sourceDamageTakenRatio = 100.0 / (100.0 + sourceEffectiveArmor);\r\n                if (sourceEffectiveArmor < 0) {\r\n                    sourceDamageTakenRatio = (100.0 - sourceEffectiveArmor) / 100.0;\r\n                }\r\n\r\n                let targetTaskDamageMultiplier = 1.0 + target.combatDetails.combatStats.taskDamage;\r\n                let sourceDamageTakenMultiplier = 1.0 + source.combatDetails.combatStats.damageTaken;\r\n                let retaliationDamageMultiplier = targetTaskDamageMultiplier * sourceDamageTakenMultiplier;\r\n\r\n                let premitigatedDamage = damageRoll;\r\n                premitigatedDamage = Math.min(premitigatedDamage, target.combatDetails.defensiveMaxDamage * 5);\r\n\r\n                let retaliationMinDamage = retaliationDamageMultiplier * target.combatDetails.combatStats.retaliation * premitigatedDamage;\r\n                let retaliationMaxDamage = retaliationDamageMultiplier * target.combatDetails.combatStats.retaliation * (target.combatDetails.defensiveMaxDamage + premitigatedDamage);\r\n\r\n                let retaliationDamageRoll = CombatUtilities.randomInt(retaliationMinDamage, retaliationMaxDamage);\r\n                let mitigatedRetaliationDamage = Math.ceil(sourceDamageTakenRatio * retaliationDamageRoll);\r\n                retaliationDamageDone = Math.min(mitigatedRetaliationDamage, source.combatDetails.currentHitpoints);\r\n                source.combatDetails.currentHitpoints -= retaliationDamageDone;\r\n            }\r\n        }\r\n\r\n        let lifeStealHeal = 0;\r\n        if (!abilityEffect && didHit && source.combatDetails.combatStats.lifeSteal > 0) {\r\n            lifeStealHeal = source.addHitpoints(Math.floor(source.combatDetails.combatStats.lifeSteal * damageDone));\r\n        }\r\n\r\n        let hpDrain = 0;\r\n        if (abilityEffect && didHit && abilityEffect.hpDrainRatio > 0) {\r\n            let healingAmplify = 1 + source.combatDetails.combatStats.healingAmplify;\r\n            hpDrain = source.addHitpoints(Math.floor(abilityEffect.hpDrainRatio * damageDone * healingAmplify));\r\n        }\r\n\r\n        let manaLeechMana = 0;\r\n        if (!abilityEffect && didHit && source.combatDetails.combatStats.manaLeech > 0) {\r\n            manaLeechMana = source.addManapoints(Math.floor(source.combatDetails.combatStats.manaLeech * damageDone));\r\n        }\r\n\r\n        return { damageDone, didHit, thornDamageDone, thornType, retaliationDamageDone, lifeStealHeal, hpDrain, manaLeechMana, isCrit};\r\n    }\r\n\r\n    static processHeal(source, abilityEffect, target) {\r\n        if (abilityEffect.combatStyleHrid != \"/combat_styles/magic\") {\r\n            throw new Error(\"Heal ability effect not supported for combat style: \" + abilityEffect.combatStyleHrid);\r\n        }\r\n\r\n        let healingAmplify = 1 + source.combatDetails.combatStats.healingAmplify;\r\n        let magicMaxDamage = source.combatDetails.magicMaxDamage;\r\n\r\n        let baseHealFlat = abilityEffect.damageFlat;\r\n        let baseHealRatio = abilityEffect.damageRatio;\r\n\r\n        let minHeal = healingAmplify * (1 + baseHealFlat);\r\n        let maxHeal = healingAmplify * (baseHealRatio * magicMaxDamage + baseHealFlat);\r\n\r\n        let heal = this.randomInt(minHeal, maxHeal);\r\n        let amountHealed = target.addHitpoints(heal);\r\n\r\n        return amountHealed;\r\n    }\r\n\r\n    static processRevive(source, abilityEffect, target) {\r\n        if (abilityEffect.combatStyleHrid != \"/combat_styles/magic\") {\r\n            throw new Error(\"Heal ability effect not supported for combat style: \" + abilityEffect.combatStyleHrid);\r\n        }\r\n\r\n        let healingAmplify = 1 + source.combatDetails.combatStats.healingAmplify;\r\n        let magicMaxDamage = source.combatDetails.magicMaxDamage;\r\n\r\n        let baseHealFlat = abilityEffect.damageFlat;\r\n        let baseHealRatio = abilityEffect.damageRatio;\r\n\r\n        let minHeal = healingAmplify * (1 + baseHealFlat);\r\n        let maxHeal = healingAmplify * (baseHealRatio * magicMaxDamage + baseHealFlat);\r\n\r\n        let heal = this.randomInt(minHeal, maxHeal);\r\n        let amountHealed = target.addHitpoints(heal);\r\n        target.combatDetails.currentManapoints = target.combatDetails.maxManapoints;\r\n        target.clearCCs();\r\n\r\n        // target.clearBuffs();\r\n\r\n        return amountHealed;\r\n    }\r\n\r\n    static processSpendHp(source, abilityEffect) {\r\n        let currentHp = source.combatDetails.currentHitpoints;\r\n        let spendHpRatio = abilityEffect.spendHpRatio;\r\n\r\n        let spentHp = Math.floor(currentHp * spendHpRatio);\r\n\r\n        source.combatDetails.currentHitpoints -= spentHp;\r\n\r\n        return spentHp;\r\n    }\r\n\r\n    static calculateTickValue(totalValue, totalTicks, currentTick) {\r\n        let currentSum = Math.floor((currentTick * totalValue) / totalTicks);\r\n        let previousSum = Math.floor(((currentTick - 1) * totalValue) / totalTicks);\r\n\r\n        return currentSum - previousSum;\r\n    }\r\n}\r\n\r\nexport default CombatUtilities;\r\n","import Buff from \"./buff\";\nimport itemDetailMap from \"./data/itemDetailMap.json\";\nimport Trigger from \"./trigger\";\n\nclass Consumable {\n    constructor(hrid, triggers = null) {\n        this.hrid = hrid;\n\n        let gameConsumable = itemDetailMap[this.hrid];\n        if (!gameConsumable) {\n            throw new Error(\"No consumable found for hrid: \" + this.hrid);\n        }\n\n        this.cooldownDuration = gameConsumable.consumableDetail.cooldownDuration;\n        this.hitpointRestore = gameConsumable.consumableDetail.hitpointRestore;\n        this.manapointRestore = gameConsumable.consumableDetail.manapointRestore;\n        this.recoveryDuration = gameConsumable.consumableDetail.recoveryDuration;\n        this.catagoryHrid = gameConsumable.categoryHrid;\n\n        this.buffs = [];\n        if (gameConsumable.consumableDetail.buffs) {\n            for (const consumableBuff of gameConsumable.consumableDetail.buffs) {\n                let buff = new Buff(consumableBuff);\n                this.buffs.push(buff);\n            }\n        }\n\n        if (triggers) {\n            this.triggers = triggers;\n        } else {\n            this.triggers = [];\n            for (const defaultTrigger of gameConsumable.consumableDetail.defaultCombatTriggers) {\n                let trigger = new Trigger(\n                    defaultTrigger.dependencyHrid,\n                    defaultTrigger.conditionHrid,\n                    defaultTrigger.comparatorHrid,\n                    defaultTrigger.value\n                );\n                this.triggers.push(trigger);\n            }\n        }\n\n        this.lastUsed = Number.MIN_SAFE_INTEGER;\n    }\n\n    static createFromDTO(dto) {\n        let triggers = dto.triggers.map((trigger) => Trigger.createFromDTO(trigger));\n        let consumable = new Consumable(dto.hrid, triggers);\n\n        return consumable;\n    }\n\n    shouldTrigger(currentTime, source, target, friendlies, enemies) {\n        if (source.isStunned) {\n            return false;\n        }\n        let consumableHaste;\n        if (this.catagoryHrid.includes(\"food\")) {\n            consumableHaste = source.combatDetails.combatStats.foodHaste\n        } else {\n            consumableHaste = source.combatDetails.combatStats.drinkConcentration;\n        }\n        let cooldownDuration = this.cooldownDuration;\n        if (consumableHaste > 0) {\n            cooldownDuration = cooldownDuration / (1 + consumableHaste);\n        }\n\n        if (this.lastUsed + cooldownDuration > currentTime) {\n            return false;\n        }\n\n        if (this.triggers.length == 0) {\n            return true;\n        }\n\n        let shouldTrigger = true;\n        for (const trigger of this.triggers) {\n            if (!trigger.isActive(source, target, friendlies, enemies, currentTime)) {\n                shouldTrigger = false;\n            }\n        }\n\n        return shouldTrigger;\n    }\n}\n\nexport default Consumable;\n","class Drops {\n\n    constructor(itemHrid, dropRate, minCount, maxCount, difficultyTier) {\n        this.itemHrid = itemHrid;\n        this.dropRate = dropRate;\n        this.minCount = minCount;\n        this.maxCount = maxCount;\n        this.difficultyTier = difficultyTier;\n    }\n}\n\nexport default Drops;\n","import itemDetailMap from \"./data/itemDetailMap.json\";\nimport enhancementLevelTotalMultiplierTable from \"./data/enhancementLevelTotalBonusMultiplierTable.json\";\n\nclass Equipment {\n    constructor(hrid, enhancementLevel) {\n        this.hrid = hrid;\n        let gameItem = itemDetailMap[this.hrid];\n        if (!gameItem) {\n            throw new Error(\"No equipment found for hrid: \" + this.hrid);\n        }\n        this.gameItem = gameItem;\n        this.enhancementLevel = enhancementLevel;\n    }\n\n    static createFromDTO(dto) {\n        let equipment = new Equipment(dto.hrid, dto.enhancementLevel);\n\n        return equipment;\n    }\n\n    getCombatStat(combatStat) {\n        let multiplier = enhancementLevelTotalMultiplierTable[this.enhancementLevel];\n        if(this.gameItem.equipmentDetail.combatStats[combatStat]) {\n            let enhancementBonus = this.gameItem.equipmentDetail.combatEnhancementBonuses[combatStat] || 0;\n            let stat = this.gameItem.equipmentDetail.combatStats[combatStat] + multiplier * enhancementBonus;\n            return stat;\n        }\n        return 0;\n    }\n\n    getCombatStyle() {\n        return this.gameItem.equipmentDetail.combatStats.combatStyleHrids[0];\n    }\n\n    getDamageType() {\n        return this.gameItem.equipmentDetail.combatStats.damageType;\n    }\n\n    getPrimaryTraining() {\n        return this.gameItem.equipmentDetail.combatStats.primaryTraining;\n    }\n\n    getFocusTraining(){\n        return this.gameItem.equipmentDetail.combatStats.focusTraining;\n    }\n}\n\nexport default Equipment;\n","import CombatEvent from \"./combatEvent\";\n\nclass AbilityCastEndEvent extends CombatEvent {\n    static type = \"abilityCastEndEvent\";\n\n    constructor(time, source, ability) {\n        super(AbilityCastEndEvent.type, time);\n\n        this.source = source;\n        this.ability = ability;\n    }\n}\n\nexport default AbilityCastEndEvent;","import CombatEvent from \"./combatEvent\";\n\nclass AutoAttackEvent extends CombatEvent {\n    static type = \"autoAttack\";\n\n    constructor(time, source) {\n        super(AutoAttackEvent.type, time);\n\n        this.source = source;\n    }\n}\n\nexport default AutoAttackEvent;\n","import CombatEvent from \"./combatEvent\";\n\nclass AwaitCooldownEvent extends CombatEvent {\n    static type = \"awaitCooldownEvent\";\n\n    constructor(time, source) {\n        super(AwaitCooldownEvent.type, time);\n\n        this.source = source;\n    }\n}\n\nexport default AwaitCooldownEvent;","import CombatEvent from \"./combatEvent\";\n\nclass BlindExpirationEvent extends CombatEvent {\n    static type = \"blindExpiration\";\n\n    constructor(time, source) {\n        super(BlindExpirationEvent.type, time);\n\n        this.source = source;\n    }\n}\n\nexport default BlindExpirationEvent;","import CombatEvent from \"./combatEvent\";\n\nclass CheckBuffExpirationEvent extends CombatEvent {\n    static type = \"checkBuffExpiration\";\n\n    constructor(time, source) {\n        super(CheckBuffExpirationEvent.type, time);\n\n        this.source = source;\n    }\n}\n\nexport default CheckBuffExpirationEvent;\n","class CombatEvent {\n    constructor(type, time) {\n        this.type = type;\n        this.time = time;\n    }\n}\n\nexport default CombatEvent;\n","import CombatEvent from \"./combatEvent\";\n\nclass CombatStartEvent extends CombatEvent {\n    static type = \"combatStart\";\n\n    constructor(time) {\n        super(CombatStartEvent.type, time);\n    }\n}\n\nexport default CombatStartEvent;\n","import CombatEvent from \"./combatEvent\";\n\nclass ConsumableTickEvent extends CombatEvent {\n    static type = \"consumableTick\";\n\n    constructor(time, source, consumable, totalTicks, currentTick) {\n        super(ConsumableTickEvent.type, time);\n\n        this.source = source;\n        this.consumable = consumable;\n        this.totalTicks = totalTicks;\n        this.currentTick = currentTick;\n    }\n}\n\nexport default ConsumableTickEvent;\n","import CombatEvent from \"./combatEvent\";\n\nclass CooldownReadyEvent extends CombatEvent {\n    static type = \"cooldownReady\";\n\n    constructor(time) {\n        super(CooldownReadyEvent.type, time);\n    }\n}\n\nexport default CooldownReadyEvent;\n","import CombatEvent from \"./combatEvent\";\n\nclass CurseExpirationEvent extends CombatEvent {\n    static type = \"curseExpiration\";\n    static maxCurseStacks = 5;\n\n    constructor(time, curseAmount, source) {\n        super(CurseExpirationEvent.type, time);\n\n        this.curseAmount = Math.min(curseAmount + 1, CurseExpirationEvent.maxCurseStacks);\n\n        this.source = source;\n    }\n}\n\nexport default CurseExpirationEvent;","import CombatEvent from \"./combatEvent\";\n\nclass DamageOverTimeEvent extends CombatEvent {\n    static type = \"damageOverTime\";\n\n    constructor(time, sourceRef, target, damage, totalTicks, currentTick, combatStyleHrid) {\n        super(DamageOverTimeEvent.type, time);\n\n        // Calling it 'source' would wrongly clear Damage Over Time when the source dies\n        this.sourceRef = sourceRef;\n        this.target = target;\n        this.damage = damage;\n        this.totalTicks = totalTicks;\n        this.currentTick = currentTick;\n        this.combatStyleHrid = combatStyleHrid;\n    }\n}\n\nexport default DamageOverTimeEvent;\n","import CombatEvent from \"./combatEvent\";\n\nclass EnemyRespawnEvent extends CombatEvent {\n    static type = \"enemyRespawn\";\n\n    constructor(time) {\n        super(EnemyRespawnEvent.type, time);\n    }\n}\n\nexport default EnemyRespawnEvent;\n","import CombatEvent from \"./combatEvent\";\n\nclass EnrageTickEvent extends CombatEvent {\n    static type = \"enrageTick\";\n\n    constructor(time, encounterTime) {\n\n        super(EnrageTickEvent.type, time);\n\n        this.encounterTime = encounterTime;\n    }\n}\n\nexport default EnrageTickEvent;\n","import Heap from \"heap-js\";\n\nclass EventQueue {\n    constructor() {\n        this.minHeap = new Heap((a, b) => a.time - b.time);\n    }\n\n    addEvent(event) {\n        this.minHeap.push(event);\n    }\n\n    getNextEvent() {\n        return this.minHeap.pop();\n    }\n\n    containsEventOfType(type) {\n        let heapEvents = this.minHeap.toArray();\n\n        return heapEvents.some((event) => event.type == type);\n    }\n\n    containsEventOfTypeAndHrid(type, hrid) {\n        let heapEvents = this.minHeap.toArray();\n        return heapEvents.some((event) => event.type == type && event.hrid == hrid);\n    }\n\n    clear() {\n        this.minHeap = new Heap((a, b) => a.time - b.time);\n    }\n\n    clearEventsForUnit(unit) {\n        this.clearMatching((event) => event.source == unit || event.target == unit);\n    }\n\n    clearEventsOfType(type) {\n        this.clearMatching((event) => event.type == type);\n    }\n\n    clearMatching(fn) {\n        let cleared = false;\n        let heapEvents = this.minHeap.toArray();\n\n        for (const event of heapEvents) {\n            if (fn(event)) {\n                this.minHeap.remove(event);\n                cleared = true;\n            }\n        }\n        return cleared;\n    }\n\n    getMatching(fn) {\n        let heapEvents = this.minHeap.toArray(); \n    \n        for (const event of heapEvents) {\n            if (fn(event)) {\n                return event; \n            }\n        }\n    \n        return null; \n    }\n}\n\nexport default EventQueue;\n","import CombatEvent from \"./combatEvent\";\n\nclass FuryExpirationEvent extends CombatEvent {\n    static type = \"furyExpiration\";\n\n    constructor(time, furyAmount, source) {\n        super(FuryExpirationEvent.type, time);\n        \n        this.furyAmount = furyAmount;\n        this.source = source;\n    }\n}\n\nexport default FuryExpirationEvent;","import CombatEvent from \"./combatEvent\";\n\nclass PlayerRespawnEvent extends CombatEvent {\n    static type = \"playerRespawn\";\n\n    constructor(time, hrid) {\n        super(PlayerRespawnEvent.type, time);\n        this.hrid = hrid;\n    }\n}\n\nexport default PlayerRespawnEvent;\n","import CombatEvent from \"./combatEvent\";\n\nclass RegenTickEvent extends CombatEvent {\n    static type = \"regenTick\";\n\n    constructor(time) {\n        super(RegenTickEvent.type, time);\n    }\n}\n\nexport default RegenTickEvent;\n","import CombatEvent from \"./combatEvent\";\n\nclass SilenceExpirationEvent extends CombatEvent {\n    static type = \"silenceExpiration\";\n\n    constructor(time, source) {\n        super(SilenceExpirationEvent.type, time);\n\n        this.source = source;\n    }\n}\n\nexport default SilenceExpirationEvent;","import CombatEvent from \"./combatEvent\";\n\nclass StunExpirationEvent extends CombatEvent {\n    static type = \"stunExpiration\";\n\n    constructor(time, source) {\n        super(StunExpirationEvent.type, time);\n\n        this.source = source;\n    }\n}\n\nexport default StunExpirationEvent;","import CombatEvent from \"./combatEvent\";\n\nclass WeakenExpirationEvent extends CombatEvent {\n    static type = \"weakenExpiration\";\n    static maxWeakenStacks = 5;\n\n    constructor(time, weakenAmount, source) {\n        super(WeakenExpirationEvent.type, time);\n        this.weakenAmount = Math.min(\n            weakenAmount + 1,\n            WeakenExpirationEvent.maxWeakenStacks\n        );\n        this.source = source;\n    }\n}\n\nexport default WeakenExpirationEvent;","import Buff from \"./buff\";\nimport houseRoomDetailMap from \"./data/houseRoomDetailMap.json\";\n\nclass HouseRoom {\n    constructor(hrid, level) {\n        this.hrid = hrid;\n        this.level = level;\n\n        let gameHouseRoom = houseRoomDetailMap[this.hrid];\n        if (!gameHouseRoom) {\n            throw new Error(\"No house room found for hrid: \" + this.hrid);\n        }\n\n        this.buffs = [];\n        if (gameHouseRoom.actionBuffs) {\n            for (const actionBuff of gameHouseRoom.actionBuffs) {\n                let buff = new Buff(actionBuff, level);\n                this.buffs.push(buff);\n            }\n        }\n        if (gameHouseRoom.globalBuffs) {\n            for (const globalBuff of gameHouseRoom.globalBuffs) {\n                let buff = new Buff(globalBuff, level);\n                this.buffs.push(buff);\n            }\n        }\n    }\n}\n\nexport default HouseRoom;","import Ability from \"./ability\";\r\nimport CombatUnit from \"./combatUnit\";\r\nimport combatMonsterDetailMap from \"./data/combatMonsterDetailMap.json\";\r\nimport Drops from \"./drops\";\r\n\r\nclass Monster extends CombatUnit {\r\n\r\n    difficultyTier = 0;\r\n\r\n    constructor(hrid, difficultyTier = 0, mazeDifficulty = 100, isMaze = false) {\r\n        super();\r\n\r\n        this.isPlayer = false;\r\n        this.hrid = hrid;\r\n        this.difficultyTier = difficultyTier;\r\n        this.mazeDifficulty = Math.max(1, Math.floor(Number(mazeDifficulty) || 100));\r\n        this.isMaze = Boolean(isMaze);\r\n        let gameMonster = combatMonsterDetailMap[this.hrid];\r\n        if (!gameMonster) {\r\n            throw new Error(\"No monster found for hrid: \" + this.hrid);\r\n        }\r\n\r\n        this.enrageTime = gameMonster.enrageTime;\r\n\r\n        // Ability level for maze encounters: direct assignment based on maze difficulty\r\n        // newLevel = Math.max(1, Math.floor(this.mazeDifficulty / 2)) when isMaze, otherwise use original level\r\n        for (let i = 0; i < gameMonster.abilities.length; i++) {\r\n            if (gameMonster.abilities[i].minDifficultyTier > this.difficultyTier) {\r\n                continue;\r\n            }\r\n            const baseLevel = gameMonster.abilities[i].level || 1;\r\n            const newLevel = this.isMaze ? Math.max(1, Math.floor(this.mazeDifficulty / 2)) : baseLevel;\r\n            this.abilities[i] = new Ability(gameMonster.abilities[i].abilityHrid, newLevel);\r\n        }\r\n        if(gameMonster.dropTable)\r\n        for (let i = 0; i < gameMonster.dropTable.length; i++) {\r\n            this.dropTable[i] = new Drops(gameMonster.dropTable[i].itemHrid, gameMonster.dropTable[i].dropRate, gameMonster.dropTable[i].minCount, gameMonster.dropTable[i].maxCount, gameMonster.dropTable[i].difficultyTier);\r\n        }\r\n        for (let i = 0; i < gameMonster.rareDropTable.length; i++) {\r\n            let dropTableItem = (gameMonster.dropTable && i < gameMonster.dropTable.length) ? gameMonster.dropTable[i] : null;\r\n            let difficultyTier = dropTableItem?.difficultyTier ?? gameMonster.rareDropTable[i].minDifficultyTier;\r\n\r\n            this.rareDropTable[i] = new Drops(gameMonster.rareDropTable[i].itemHrid, gameMonster.rareDropTable[i].dropRate, gameMonster.rareDropTable[i].minCount, difficultyTier);\r\n        }\r\n    }\r\n\r\n    updateCombatDetails() {\r\n        let gameMonster = combatMonsterDetailMap[this.hrid];\r\n\r\n        let levelMultiplier = 1.0 + 0.25 * this.difficultyTier;\r\n        let defLevelMultiplier = 1.0 + 0.15 * this.difficultyTier;\r\n        let levelBonus = 20.0 * this.difficultyTier;\r\n        // If this is a maze encounter, scale base levels by mazeDifficulty/100\r\n        let mazeScale = this.isMaze ? (this.mazeDifficulty / 100) : 1;\r\n\r\n        this.staminaLevel = levelMultiplier * (gameMonster.combatDetails.staminaLevel + levelBonus) * mazeScale;\r\n        this.intelligenceLevel = levelMultiplier * (gameMonster.combatDetails.intelligenceLevel + levelBonus) * mazeScale;\r\n        this.attackLevel = levelMultiplier * (gameMonster.combatDetails.attackLevel + levelBonus) * mazeScale;\r\n        this.meleeLevel = levelMultiplier * (gameMonster.combatDetails.meleeLevel + levelBonus) * mazeScale;\r\n        this.defenseLevel = defLevelMultiplier * (gameMonster.combatDetails.defenseLevel + levelBonus) * mazeScale;\r\n        this.rangedLevel = levelMultiplier * (gameMonster.combatDetails.rangedLevel + levelBonus) * mazeScale;\r\n        this.magicLevel = levelMultiplier * (gameMonster.combatDetails.magicLevel + levelBonus) * mazeScale;\r\n\r\n        \r\n        let expMultiplier = 1.0 + 0.5 * this.difficultyTier;\r\n        let expBonus = 5.0 * this.difficultyTier;\r\n\r\n        this.experience = expMultiplier * (gameMonster.experience + expBonus);\r\n\r\n        this.combatDetails.combatStats.combatStyleHrid = gameMonster.combatDetails.combatStats.combatStyleHrids[0];\r\n\r\n        for (const [key, value] of Object.entries(gameMonster.combatDetails.combatStats)) {\r\n            this.combatDetails.combatStats[key] = value;\r\n        }\r\n\r\n        [\r\n            \"stabAccuracy\",\r\n            \"slashAccuracy\",\r\n            \"smashAccuracy\",\r\n            \"rangedAccuracy\",\r\n            \"magicAccuracy\",\r\n            \"stabDamage\",\r\n            \"slashDamage\",\r\n            \"smashDamage\",\r\n            \"rangedDamage\",\r\n            \"magicDamage\",\r\n            \"defensiveDamage\",\r\n            \"taskDamage\",\r\n            \"physicalAmplify\",\r\n            \"waterAmplify\",\r\n            \"natureAmplify\",\r\n            \"fireAmplify\",\r\n            \"healingAmplify\",\r\n            \"stabEvasion\",\r\n            \"slashEvasion\",\r\n            \"smashEvasion\",\r\n            \"rangedEvasion\",\r\n            \"magicEvasion\",\r\n            \"armor\",\r\n            \"waterResistance\",\r\n            \"natureResistance\",\r\n            \"fireResistance\",\r\n            \"maxHitpoints\",\r\n            \"maxManapoints\",\r\n            \"lifeSteal\",\r\n            \"hpRegenPer10\",\r\n            \"mpRegenPer10\",\r\n            \"physicalThorns\",\r\n            \"elementalThorns\",\r\n            \"combatDropRate\",\r\n            \"combatRareFind\",\r\n            \"combatDropQuantity\",\r\n            \"combatExperience\",\r\n            \"criticalRate\",\r\n            \"criticalDamage\",\r\n            \"armorPenetration\",\r\n            \"waterPenetration\",\r\n            \"naturePenetration\",\r\n            \"firePenetration\",\r\n            \"abilityHaste\",\r\n            \"tenacity\",\r\n            \"manaLeech\",\r\n            \"castSpeed\",\r\n            \"threat\",\r\n            \"parry\",\r\n            \"mayhem\",\r\n            \"pierce\",\r\n            \"curse\",\r\n            \"fury\",\r\n            \"weaken\",\r\n            \"ripple\",\r\n            \"bloom\",\r\n            \"blaze\",\r\n            \"attackSpeed\",\r\n            \"foodHaste\",\r\n            \"drinkConcentration\",\r\n            \"autoAttackDamage\",\r\n            \"abilityDamage\",\r\n            \"retaliation\"\r\n        ].forEach((stat) => {\r\n            if (gameMonster.combatDetails.combatStats[stat] == null) {\r\n                this.combatDetails.combatStats[stat] = 0;\r\n            }\r\n        });\r\n\r\n        if (this.combatDetails.combatStats.attackInterval == 0) {\r\n            this.combatDetails.combatStats.attackInterval = gameMonster.combatDetails.attackInterval;\r\n        }\r\n\r\n        super.updateCombatDetails();\r\n    }\r\n}\r\n\r\nexport default Monster;\r\n","import Ability from \"./ability\";\r\nimport CombatUnit from \"./combatUnit\";\r\nimport Consumable from \"./consumable\";\r\nimport Equipment from \"./equipment\";\r\nimport HouseRoom from \"./houseRoom\";\r\nimport Achievement from \"./achievement\";\r\n\r\nclass Player extends CombatUnit {\r\n    equipment = {\r\n        \"/equipment_types/head\": null,\r\n        \"/equipment_types/body\": null,\r\n        \"/equipment_types/legs\": null,\r\n        \"/equipment_types/feet\": null,\r\n        \"/equipment_types/hands\": null,\r\n        \"/equipment_types/main_hand\": null,\r\n        \"/equipment_types/two_hand\": null,\r\n        \"/equipment_types/off_hand\": null,\r\n        \"/equipment_types/pouch\": null,\r\n        \"/equipment_types/back\": null,\r\n    };\r\n\r\n    constructor() {\r\n        super();\r\n\r\n        this.isPlayer = true;\r\n        this.hrid = \"player\";\r\n    }\r\n\r\n    static createFromDTO(dto) {\r\n        let player = new Player();\r\n\r\n        player.staminaLevel = dto.staminaLevel;\r\n        player.intelligenceLevel = dto.intelligenceLevel;\r\n        player.attackLevel = dto.attackLevel;\r\n        player.meleeLevel = dto.meleeLevel;\r\n        player.defenseLevel = dto.defenseLevel;\r\n        player.rangedLevel = dto.rangedLevel;\r\n        player.magicLevel = dto.magicLevel;\r\n\r\n        player.hrid = dto.hrid;\r\n\r\n        for (const [key, value] of Object.entries(dto.equipment)) {\r\n            player.equipment[key] = value ? Equipment.createFromDTO(value) : null;\r\n        }\r\n\r\n        player.food = dto.food.map((food) => (food ? Consumable.createFromDTO(food) : null));\r\n        player.drinks = dto.drinks.map((drink) => (drink ? Consumable.createFromDTO(drink) : null));\r\n        player.abilities = dto.abilities.map((ability) => (ability ? Ability.createFromDTO(ability) : null));\r\n        Object.entries(dto.houseRooms).forEach(houseRoom => {\r\n            if (houseRoom[1] > 0) {\r\n                player.houseRooms.push(new HouseRoom(houseRoom[0], houseRoom[1]))\r\n            }\r\n        });\r\n\r\n        player.achievements = new Achievement(dto.achievements);\r\n\r\n        player.debuffOnLevelGap = dto.debuffOnLevelGap;\r\n\r\n        return player;\r\n    }\r\n\r\n    updateCombatDetails() {\r\n        if (this.equipment[\"/equipment_types/main_hand\"]) {\r\n            this.combatDetails.combatStats.combatStyleHrid =\r\n                this.equipment[\"/equipment_types/main_hand\"].getCombatStyle();\r\n            this.combatDetails.combatStats.damageType = this.equipment[\"/equipment_types/main_hand\"].getDamageType();\r\n            this.combatDetails.combatStats.attackInterval =\r\n                this.equipment[\"/equipment_types/main_hand\"].getCombatStat(\"attackInterval\");\r\n            this.combatDetails.combatStats.primaryTraining = \r\n                this.equipment[\"/equipment_types/main_hand\"].getPrimaryTraining();\r\n        } else if (this.equipment[\"/equipment_types/two_hand\"]) {\r\n            this.combatDetails.combatStats.combatStyleHrid =\r\n                this.equipment[\"/equipment_types/two_hand\"].getCombatStyle();\r\n            this.combatDetails.combatStats.damageType = this.equipment[\"/equipment_types/two_hand\"].getDamageType();\r\n            this.combatDetails.combatStats.attackInterval =\r\n                this.equipment[\"/equipment_types/two_hand\"].getCombatStat(\"attackInterval\");\r\n            this.combatDetails.combatStats.primaryTraining = \r\n                this.equipment[\"/equipment_types/two_hand\"].getPrimaryTraining();\r\n        } else {\r\n            this.combatDetails.combatStats.combatStyleHrid = \"/combat_styles/smash\";\r\n            this.combatDetails.combatStats.damageType = \"/damage_types/physical\";\r\n            this.combatDetails.combatStats.attackInterval = 3000000000;\r\n            this.combatDetails.combatStats.primaryTraining = \"/skills/melee\";\r\n        }\r\n\r\n        if (this.equipment[\"/equipment_types/charm\"]) {\r\n            this.combatDetails.combatStats.focusTraining = this.equipment[\"/equipment_types/charm\"].getFocusTraining();\r\n        } else {\r\n            this.combatDetails.combatStats.focusTraining = \"\";\r\n        }\r\n\r\n        [\r\n            \"stabAccuracy\",\r\n            \"slashAccuracy\",\r\n            \"smashAccuracy\",\r\n            \"rangedAccuracy\",\r\n            \"magicAccuracy\",\r\n            \"stabDamage\",\r\n            \"slashDamage\",\r\n            \"smashDamage\",\r\n            \"rangedDamage\",\r\n            \"magicDamage\",\r\n            \"defensiveDamage\",\r\n            \"taskDamage\",\r\n            \"physicalAmplify\",\r\n            \"waterAmplify\",\r\n            \"natureAmplify\",\r\n            \"fireAmplify\",\r\n            \"healingAmplify\",\r\n            \"stabEvasion\",\r\n            \"slashEvasion\",\r\n            \"smashEvasion\",\r\n            \"rangedEvasion\",\r\n            \"magicEvasion\",\r\n            \"armor\",\r\n            \"waterResistance\",\r\n            \"natureResistance\",\r\n            \"fireResistance\",\r\n            \"maxHitpoints\",\r\n            \"maxManapoints\",\r\n            \"lifeSteal\",\r\n            \"hpRegenPer10\",\r\n            \"mpRegenPer10\",\r\n            \"physicalThorns\",\r\n            \"elementalThorns\",\r\n            \"combatDropRate\",\r\n            \"combatRareFind\",\r\n            \"combatDropQuantity\",\r\n            \"combatExperience\",\r\n            \"criticalRate\",\r\n            \"criticalDamage\",\r\n            \"armorPenetration\",\r\n            \"waterPenetration\",\r\n            \"naturePenetration\",\r\n            \"firePenetration\",\r\n            \"abilityHaste\",\r\n            \"tenacity\",\r\n            \"manaLeech\",\r\n            \"castSpeed\",\r\n            \"threat\",\r\n            \"parry\",\r\n            \"mayhem\",\r\n            \"pierce\",\r\n            \"curse\",\r\n            \"fury\",\r\n            \"weaken\",\r\n            \"ripple\",\r\n            \"bloom\",\r\n            \"blaze\",\r\n            \"attackSpeed\",\r\n            \"foodHaste\",\r\n            \"drinkConcentration\",\r\n            \"autoAttackDamage\",\r\n            \"abilityDamage\",\r\n            \"staminaExperience\",\r\n            \"intelligenceExperience\",\r\n            \"attackExperience\",\r\n            \"defenseExperience\",\r\n            \"meleeExperience\",\r\n            \"rangedExperience\",\r\n            \"magicExperience\",\r\n            \"retaliation\"\r\n        ].forEach((stat) => {\r\n            this.combatDetails.combatStats[stat] = Object.values(this.equipment)\r\n                .filter((equipment) => equipment != null)\r\n                .map((equipment) => equipment.getCombatStat(stat))\r\n                .reduce((prev, cur) => prev + cur, 0);\r\n        });\r\n\r\n        if (this.equipment[\"/equipment_types/pouch\"]) {\r\n            this.combatDetails.combatStats.foodSlots =\r\n                1 + this.equipment[\"/equipment_types/pouch\"].getCombatStat(\"foodSlots\");\r\n            this.combatDetails.combatStats.drinkSlots =\r\n                1 + this.equipment[\"/equipment_types/pouch\"].getCombatStat(\"drinkSlots\");\r\n        } else {\r\n            this.combatDetails.combatStats.foodSlots = 1;\r\n            this.combatDetails.combatStats.drinkSlots = 1;\r\n        }\r\n\r\n        super.updateCombatDetails();\r\n    }\r\n}\r\n\r\nexport default Player;\r\n","import combatStyleDetailMap from \"./data/combatStyleDetailMap.json\"\r\n\r\nclass SimResult {\r\n    constructor(zone, numberOfPlayers) {\r\n        this.deaths = {};\r\n        this.experienceGained = {};\r\n        this.encounters = 0;\r\n        this.attacks = {};\r\n        this.consumablesUsed = {};\r\n        this.hitpointsGained = {};\r\n        this.manapointsGained = {};\r\n        this.debuffOnLevelGap = {};\r\n        this.dropRateMultiplier = {};\r\n        this.rareFindMultiplier = {};\r\n        this.combatDropQuantity = {};\r\n        this.playerRanOutOfMana = {\r\n            \"player1\": false,\r\n            \"player2\": false,\r\n            \"player3\": false,\r\n            \"player4\": false,\r\n            \"player5\": false\r\n        };\r\n        this.playerRanOutOfManaTime = {};\r\n        this.manaUsed = {};\r\n        this.timeSpentAlive = [];\r\n        this.bossSpawns = [];\r\n        this.hitpointsSpent = {};\r\n        this.zoneName = zone.hrid;\r\n        this.difficultyTier = zone.difficultyTier;\r\n        this.isDungeon = false;\r\n        this.dungeonsCompleted = 0;\r\n        this.dungeonsFailed = 0;\r\n        this.maxWaveReached = 0;\r\n        this.numberOfPlayers = numberOfPlayers;\r\n        this.maxEnrageStack = 0;\r\n        this.minDungenonTime = 0;\r\n        this.lastDungeonFinishTime = 0;\r\n        this.lastEncounterFinishTime = 0;\r\n\r\n        this.wipeEvents = [];\r\n        \r\n        // 时间序列数据用于图表显示\r\n        this.timeSeriesData = {\r\n            timestamps: [],\r\n            players: {}\r\n        };\r\n    }\r\n\r\n    addWipeEvent(logs, simulationTime, wave) {\r\n        this.wipeEvents.push({\r\n            simulationTime: simulationTime,\r\n            logs: logs,\r\n            wave: wave,\r\n            timestamp: new Date().toISOString()\r\n        });\r\n    }\r\n    \r\n    addDeath(unit) {\r\n        if (!this.deaths[unit.hrid]) {\r\n            this.deaths[unit.hrid] = 0;\r\n        }\r\n\r\n        this.deaths[unit.hrid] += 1;\r\n    }\r\n\r\n    updateTimeSpentAlive(name, alive, time) {\r\n        const i = this.timeSpentAlive.findIndex(e => e.name === name);\r\n        if (alive) {\r\n            if (i !== -1) {\r\n                this.timeSpentAlive[i].alive = true;\r\n                this.timeSpentAlive[i].spawnedAt = time;\r\n            } else {\r\n                this.timeSpentAlive.push({ name: name, timeSpentAlive: 0, spawnedAt: time, alive: true, count: 0 });\r\n            }\r\n        } else {\r\n            const timeAlive = time - this.timeSpentAlive[i].spawnedAt;\r\n            this.timeSpentAlive[i].alive = false;\r\n            this.timeSpentAlive[i].timeSpentAlive += timeAlive;\r\n            this.timeSpentAlive[i].count += 1;\r\n        }\r\n    }\r\n\r\n    updateDungenonFinish(beginFlag, finishTime) {\r\n        const i = this.timeSpentAlive.findIndex(e => e.name === beginFlag); \r\n        if (i == -1) {\r\n            return;\r\n        }\r\n\r\n        const currentDungenonTime = finishTime - this.timeSpentAlive[i].spawnedAt;\r\n\r\n        if (this.minDungenonTime == 0 || this.minDungenonTime > currentDungenonTime) {\r\n            this.minDungenonTime = currentDungenonTime;\r\n        }\r\n    }\r\n\r\n    addExperienceGain(unit, experience) {\r\n        if (!unit.isPlayer) {\r\n            return;\r\n        }\r\n\r\n        if (!this.experienceGained[unit.hrid]) {\r\n            this.experienceGained[unit.hrid] = {\r\n                stamina: 0,\r\n                intelligence: 0,\r\n                attack: 0,\r\n                melee: 0,\r\n                defense: 0,\r\n                ranged: 0,\r\n                magic: 0,\r\n            };\r\n        }\r\n\r\n        let experienceGainedRate = {\r\n            \"stamina\": 0,\r\n            \"intelligence\": 0,\r\n            \"attack\": 0,\r\n            \"melee\": 0,\r\n            \"defense\": 0,\r\n            \"ranged\": 0,\r\n            \"magic\": 0,\r\n        };\r\n\r\n        const primaryTraining = unit.combatDetails.combatStats.primaryTraining;\r\n        experienceGainedRate[primaryTraining.split(\"/\")[2]] = .3;\r\n\r\n        const skillExpMap = combatStyleDetailMap[unit.combatDetails.combatStats.combatStyleHrid].skillExpMap;\r\n        const skillExpMapLength = Object.keys(skillExpMap).length;\r\n\r\n        const focusTraining = unit.combatDetails.combatStats.focusTraining;\r\n        if (focusTraining && skillExpMap[focusTraining]) {\r\n            experienceGainedRate[focusTraining.split(\"/\")[2]] += .7;\r\n        } else {\r\n            Object.keys(skillExpMap).forEach(skillHrid => {\r\n                experienceGainedRate[skillHrid.split(\"/\")[2]] += .7 / skillExpMapLength;\r\n            });\r\n        }\r\n\r\n        for (const [type, rate] of Object.entries(experienceGainedRate)) {\r\n            if (rate <= 0) continue;\r\n\r\n            const skillExperience = rate * (1 + unit.combatDetails.combatStats[type + \"Experience\"]);\r\n\r\n            this.experienceGained[unit.hrid][type] += (\r\n                experience\r\n                * (1 + unit.combatDetails.combatStats.combatExperience)\r\n                * skillExperience\r\n                * (1 + unit.debuffOnLevelGap)\r\n\r\n            );\r\n        }\r\n    }\r\n\r\n    addEncounterEnd() {\r\n        this.encounters++;\r\n    }\r\n\r\n    addAttack(source, target, ability, hit) {\r\n        if (!this.attacks[source.hrid]) {\r\n            this.attacks[source.hrid] = {};\r\n        }\r\n        if (!this.attacks[source.hrid][target.hrid]) {\r\n            this.attacks[source.hrid][target.hrid] = {};\r\n        }\r\n        if (!this.attacks[source.hrid][target.hrid][ability]) {\r\n            this.attacks[source.hrid][target.hrid][ability] = {};\r\n        }\r\n\r\n        if (!this.attacks[source.hrid][target.hrid][ability][hit]) {\r\n            this.attacks[source.hrid][target.hrid][ability][hit] = 0;\r\n        }\r\n\r\n        this.attacks[source.hrid][target.hrid][ability][hit] += 1;\r\n    }\r\n\r\n    addConsumableUse(unit, consumable) {\r\n        if (!this.consumablesUsed[unit.hrid]) {\r\n            this.consumablesUsed[unit.hrid] = {};\r\n        }\r\n        if (!this.consumablesUsed[unit.hrid][consumable.hrid]) {\r\n            this.consumablesUsed[unit.hrid][consumable.hrid] = 0;\r\n        }\r\n\r\n        this.consumablesUsed[unit.hrid][consumable.hrid] += 1;\r\n    }\r\n\r\n    addHitpointsGained(unit, source, amount) {\r\n        if (!this.hitpointsGained[unit.hrid]) {\r\n            this.hitpointsGained[unit.hrid] = {};\r\n        }\r\n        if (!this.hitpointsGained[unit.hrid][source]) {\r\n            this.hitpointsGained[unit.hrid][source] = 0;\r\n        }\r\n\r\n        this.hitpointsGained[unit.hrid][source] += amount;\r\n    }\r\n\r\n    addManapointsGained(unit, source, amount) {\r\n        if (!this.manapointsGained[unit.hrid]) {\r\n            this.manapointsGained[unit.hrid] = {};\r\n        }\r\n        if (!this.manapointsGained[unit.hrid][source]) {\r\n            this.manapointsGained[unit.hrid][source] = 0;\r\n        }\r\n\r\n        this.manapointsGained[unit.hrid][source] += amount;\r\n    }\r\n\r\n    setDropRateMultipliers(unit) {\r\n        if (!this.dropRateMultiplier[unit.hrid]) {\r\n            this.dropRateMultiplier[unit.hrid] = {};\r\n        }\r\n        this.dropRateMultiplier[unit.hrid] = 1 + unit.combatDetails.combatStats.combatDropRate;\r\n\r\n        if (!this.rareFindMultiplier[unit.hrid]) {\r\n            this.rareFindMultiplier[unit.hrid] = {};\r\n        }\r\n        this.rareFindMultiplier[unit.hrid] = 1 + unit.combatDetails.combatStats.combatRareFind;\r\n\r\n        if (!this.combatDropQuantity[unit.hrid]) {\r\n            this.combatDropQuantity[unit.hrid] = {};\r\n        }\r\n        this.combatDropQuantity[unit.hrid] = unit.combatDetails.combatStats.combatDropQuantity;\r\n\r\n        if (!this.debuffOnLevelGap[unit.hrid]) {\r\n            this.debuffOnLevelGap[unit.hrid] = {};\r\n        }\r\n        this.debuffOnLevelGap[unit.hrid] = unit.debuffOnLevelGap;\r\n    }\r\n\r\n    setManaUsed(unit) {\r\n        this.manaUsed[unit.hrid] = {};\r\n        for (let [key, value] of unit.abilityManaCosts.entries()) {\r\n            this.manaUsed[unit.hrid][key] = value;\r\n        }\r\n    }\r\n\r\n    addHitpointsSpent(unit, source, amount) {\r\n        if (!this.hitpointsSpent[unit.hrid]) {\r\n            this.hitpointsSpent[unit.hrid] = {};\r\n        }\r\n        if (!this.hitpointsSpent[unit.hrid][source]) {\r\n            this.hitpointsSpent[unit.hrid][source] = 0;\r\n        }\r\n\r\n        this.hitpointsSpent[unit.hrid][source] += amount;\r\n    }\r\n\r\n    addRanOutOfManaCount(unit, isOutOfMana, time) {\r\n        if (isOutOfMana) this.playerRanOutOfMana[unit.hrid] = true;\r\n\r\n        if (!this.playerRanOutOfManaTime[unit.hrid]) {\r\n            this.playerRanOutOfManaTime[unit.hrid] = {isOutOfMana: false, startTimeForOutOfMana:0, totalTimeForOutOfMana:0};\r\n        }\r\n\r\n        if (isOutOfMana) {\r\n            if (!this.playerRanOutOfManaTime[unit.hrid].isOutOfMana) {\r\n                this.playerRanOutOfManaTime[unit.hrid].isOutOfMana = true;\r\n                this.playerRanOutOfManaTime[unit.hrid].startTimeForOutOfMana = time;\r\n            }\r\n        } else {\r\n            if (this.playerRanOutOfManaTime[unit.hrid].isOutOfMana) {\r\n                this.playerRanOutOfManaTime[unit.hrid].isOutOfMana = false;\r\n                this.playerRanOutOfManaTime[unit.hrid].totalTimeForOutOfMana += time - this.playerRanOutOfManaTime[unit.hrid].startTimeForOutOfMana;\r\n            }\r\n        }\r\n    }\r\n\r\n    // 添加时间序列数据点\r\n    addTimeSeriesSnapshot(time, players) {\r\n        this.timeSeriesData.timestamps.push(time);\r\n        \r\n        players.forEach(player => {\r\n            if (!this.timeSeriesData.players[player.hrid]) {\r\n                this.timeSeriesData.players[player.hrid] = {\r\n                    hp: [],\r\n                    mp: [],\r\n                    maxHp: [],\r\n                    maxMp: []\r\n                };\r\n            }\r\n            \r\n            const playerData = this.timeSeriesData.players[player.hrid];\r\n            playerData.hp.push(player.combatDetails.currentHitpoints);\r\n            playerData.mp.push(player.combatDetails.currentManapoints);\r\n            playerData.maxHp.push(player.combatDetails.maxHitpoints);\r\n            playerData.maxMp.push(player.combatDetails.maxManapoints);\r\n        });\r\n    }\r\n}\r\n\r\nexport default SimResult;\r\n","import combatTriggerDependencyDetailMap from \"./data/combatTriggerDependencyDetailMap.json\";\r\n\r\nclass Trigger {\r\n    constructor(dependencyHrid, conditionHrid, comparatorHrid, value = 0) {\r\n        this.dependencyHrid = dependencyHrid;\r\n        this.conditionHrid = conditionHrid;\r\n        this.comparatorHrid = comparatorHrid;\r\n        this.value = value;\r\n    }\r\n\r\n    static createFromDTO(dto) {\r\n        let trigger = new Trigger(dto.dependencyHrid, dto.conditionHrid, dto.comparatorHrid, dto.value);\r\n\r\n        return trigger;\r\n    }\r\n\r\n    isActive(source, target, friendlies, enemies, currentTime) {\r\n        if (combatTriggerDependencyDetailMap[this.dependencyHrid].isSingleTarget) {\r\n            return this.isActiveSingleTarget(source, target, currentTime);\r\n        } else {\r\n            return this.isActiveMultiTarget(friendlies, enemies, currentTime);\r\n        }\r\n    }\r\n\r\n    isActiveSingleTarget(source, target, currentTime) {\r\n        let dependencyValue;\r\n        switch (this.dependencyHrid) {\r\n            case \"/combat_trigger_dependencies/self\":\r\n                dependencyValue = this.getDependencyValue(source, currentTime);\r\n                break;\r\n            case \"/combat_trigger_dependencies/targeted_enemy\":\r\n                if (!target) {\r\n                    return false;\r\n                }\r\n                dependencyValue = this.getDependencyValue(target, currentTime);\r\n                break;\r\n            default:\r\n                throw new Error(\"Unknown dependencyHrid in trigger: \" + this.dependencyHrid);\r\n        }\r\n\r\n        return this.compareValue(dependencyValue);\r\n    }\r\n\r\n    isActiveMultiTarget(friendlies, enemies, currentTime) {\r\n        let dependency;\r\n        switch (this.dependencyHrid) {\r\n            case \"/combat_trigger_dependencies/all_allies\":\r\n                dependency = friendlies;\r\n                break;\r\n            case \"/combat_trigger_dependencies/all_enemies\":\r\n                if (!enemies) {\r\n                    return false;\r\n                }\r\n                dependency = enemies;\r\n                break;\r\n            default:\r\n                throw new Error(\"Unknown dependencyHrid in trigger: \" + this.dependencyHrid);\r\n        }\r\n\r\n        let dependencyValue;\r\n        switch (this.conditionHrid) {\r\n            case \"/combat_trigger_conditions/number_of_active_units\":\r\n                dependencyValue = dependency.filter((unit) => unit.combatDetails.currentHitpoints > 0).length;\r\n                break;\r\n            case \"/combat_trigger_conditions/number_of_dead_units\":\r\n                dependencyValue = dependency.filter((unit) => unit.combatDetails.currentHitpoints <= 0).length;\r\n                break;\r\n            case \"/combat_trigger_conditions/lowest_hp_percentage\":\r\n                dependencyValue = dependency.filter((unit) => unit.combatDetails.currentHitpoints > 0).reduce((prev, curr) => {\r\n                    let currentHpPercentage = curr.combatDetails.currentHitpoints / curr.combatDetails.maxHitpoints;\r\n                    return currentHpPercentage < prev ? currentHpPercentage : prev;\r\n                }, 2) * 100;\r\n                break;\r\n            default:\r\n                dependencyValue = dependency\r\n                    .filter((unit) => unit.combatDetails.currentHitpoints > 0)\r\n                    .map((unit) => this.getDependencyValue(unit, currentTime))\r\n                    .reduce((prev, cur) => prev + cur, 0);\r\n                break;\r\n        }\r\n\r\n        return this.compareValue(dependencyValue);\r\n    }\r\n\r\n    getDependencyValue(source, currentTime) {\r\n        switch (this.conditionHrid) {\r\n            case \"/combat_trigger_conditions/berserk\":\r\n            case \"/combat_trigger_conditions/frenzy\":\r\n            case \"/combat_trigger_conditions/precision\":\r\n            case \"/combat_trigger_conditions/vampirism\":\r\n            case \"/combat_trigger_conditions/attack_coffee\":\r\n            case \"/combat_trigger_conditions/defense_coffee\":\r\n            case \"/combat_trigger_conditions/lucky_coffee\":\r\n            case \"/combat_trigger_conditions/magic_coffee\":\r\n            case \"/combat_trigger_conditions/melee_coffee\":\r\n            case \"/combat_trigger_conditions/ranged_coffee\":\r\n            case \"/combat_trigger_conditions/swiftness_coffee\":\r\n            case \"/combat_trigger_conditions/wisdom_coffee\":\r\n            case \"/combat_trigger_conditions/ice_spear\":\r\n            case \"/combat_trigger_conditions/puncture\":\r\n            case \"/combat_trigger_conditions/frost_surge\":\r\n            case \"/combat_trigger_conditions/elusiveness\":\r\n            case \"/combat_trigger_conditions/channeling_coffee\":\r\n            case \"/combat_trigger_conditions/fierce_aura\":\r\n            case \"/combat_trigger_conditions/invincible_armor\":\r\n            case \"/combat_trigger_conditions/invincible_fire_resistance\":\r\n            case \"/combat_trigger_conditions/invincible_nature_resistance\":\r\n            case \"/combat_trigger_conditions/invincible_water_resistance\":\r\n            case \"/combat_trigger_conditions/provoke\":\r\n            case \"/combat_trigger_conditions/taunt\":\r\n            case \"/combat_trigger_conditions/crippling_slash\":\r\n            case \"/combat_trigger_conditions/mana_spring\":\r\n            case \"/combat_trigger_conditions/retribution\":\r\n            case \"/combat_trigger_conditions/fracturing_impact\":\r\n            case \"/combat_trigger_conditions/maim\":\r\n            case \"/combat_trigger_conditions/curse\":\r\n            case \"/combat_trigger_conditions/weaken\":\r\n                let buffHrid = \"/buff_uniques\";\r\n                buffHrid += this.conditionHrid.slice(this.conditionHrid.lastIndexOf(\"/\"));\r\n                return source.combatBuffs[buffHrid];\r\n            case \"/combat_trigger_conditions/critical_aura\":\r\n            case \"/combat_trigger_conditions/critical_coffee\":\r\n            case \"/combat_trigger_conditions/intelligence_coffee\":\r\n            case \"/combat_trigger_conditions/stamina_coffee\":\r\n            case \"/combat_trigger_conditions/elemental_affinity\":\r\n            case \"/combat_trigger_conditions/fury\":\r\n            case \"/combat_trigger_conditions/guardian_aura\":\r\n            case \"/combat_trigger_conditions/insanity\":\r\n            case \"/combat_trigger_conditions/spike_shell\":\r\n            case \"/combat_trigger_conditions/toxic_pollen\":\r\n            case \"/combat_trigger_conditions/invincible\":\r\n            case \"/combat_trigger_conditions/mystic_aura\":\r\n            case \"/combat_trigger_conditions/pestilent_shot\":\r\n            case \"/combat_trigger_conditions/smoke_burst\":\r\n            case \"/combat_trigger_conditions/speed_aura\":\r\n            case \"/combat_trigger_conditions/toughness\":\r\n            case \"/combat_trigger_conditions/enrage\":\r\n                let buffPrefix = \"/buff_uniques\";\r\n                buffPrefix += this.conditionHrid.slice(this.conditionHrid.lastIndexOf(\"/\"));\r\n                let buffs = Object.keys(source.combatBuffs).filter(buff => buff.startsWith(buffPrefix));\r\n                return source.combatBuffs[buffs?.[0]];\r\n            case \"/combat_trigger_conditions/current_hp\":\r\n                return source.combatDetails.currentHitpoints;\r\n            case \"/combat_trigger_conditions/current_mp\":\r\n                return source.combatDetails.currentManapoints;\r\n            case \"/combat_trigger_conditions/missing_hp\":\r\n                return source.combatDetails.maxHitpoints - source.combatDetails.currentHitpoints;\r\n            case \"/combat_trigger_conditions/missing_mp\":\r\n                return source.combatDetails.maxManapoints - source.combatDetails.currentManapoints;\r\n            case \"/combat_trigger_conditions/stun_status\":\r\n                // Replicate the game's behaviour of \"stun status active\" triggers activating\r\n                // immediately after the stun has worn off\r\n                return source.isStunned || source.stunExpireTime == currentTime;\r\n            case \"/combat_trigger_conditions/blind_status\":\r\n                return source.isBlinded || source.blindExpireTime == currentTime;\r\n            case \"/combat_trigger_conditions/silence_status\":\r\n                return source.isSilenced || source.silenceExpireTime == currentTime;\r\n            default:\r\n                throw new Error(\"Unknown conditionHrid in trigger: \" + this.conditionHrid);\r\n        }\r\n    }\r\n\r\n    compareValue(dependencyValue) {\r\n        switch (this.comparatorHrid) {\r\n            case \"/combat_trigger_comparators/greater_than_equal\":\r\n                return dependencyValue >= this.value;\r\n            case \"/combat_trigger_comparators/less_than_equal\":\r\n                return dependencyValue <= this.value;\r\n            case \"/combat_trigger_comparators/is_active\":\r\n                return !!dependencyValue;\r\n            case \"/combat_trigger_comparators/is_inactive\":\r\n                return !dependencyValue;\r\n            default:\r\n                throw new Error(\"Unknown comparatorHrid in trigger: \" + this.comparatorHrid);\r\n        }\r\n    }\r\n}\r\n\r\nexport default Trigger;\r\n","import actionDetailMap from \"./data/actionDetailMap.json\";\r\nimport Monster from \"./monster\";\r\n\r\nclass Zone {\r\n    constructor(hrid, difficultyTier, mazeDifficulty = 100) {\r\n        this.hrid = hrid;\r\n        this.difficultyTier = difficultyTier;\r\n        this.mazeDifficulty = Math.max(1, Math.floor(Number(mazeDifficulty) || 100));\r\n\r\n        let gameZone = actionDetailMap[this.hrid];\r\n        this.monsterSpawnInfo = gameZone.combatZoneInfo.fightInfo;\r\n        this.dungeonSpawnInfo = gameZone.combatZoneInfo.dungeonInfo;\r\n        this.encountersKilled = 1;\r\n        this.monsterSpawnInfo.battlesPerBoss = 10;\r\n        this.buffs = gameZone.buffs;\r\n        this.isDungeon = gameZone.combatZoneInfo.isDungeon;\r\n        // 迷宫标志\r\n        this.isMaze = gameZone.combatZoneInfo?.isMaze || false;\r\n        this.dungeonsCompleted = 0;\r\n        this.dungeonsFailed = 0;\r\n        this.finalWave = false; \r\n    }\r\n\r\n    getRandomEncounter() {\r\n\r\n        if (this.monsterSpawnInfo.bossSpawns && this.encountersKilled == this.monsterSpawnInfo.battlesPerBoss) {\r\n            this.encountersKilled = 1;\r\n            return this.monsterSpawnInfo.bossSpawns.map((monster) => new Monster(monster.combatMonsterHrid, monster.difficultyTier + this.difficultyTier, this.mazeDifficulty, this.isMaze));\r\n        }\r\n\r\n        let totalWeight = this.monsterSpawnInfo.randomSpawnInfo.spawns.reduce((prev, cur) => prev + cur.rate, 0);\r\n\r\n        let encounterHrids = [];\r\n        let totalStrength = 0;\r\n\r\n        outer: for (let i = 0; i < this.monsterSpawnInfo.randomSpawnInfo.maxSpawnCount; i++) {\r\n            let randomWeight = totalWeight * Math.random();\r\n            let cumulativeWeight = 0;\r\n\r\n            for (const spawn of this.monsterSpawnInfo.randomSpawnInfo.spawns) {\r\n                cumulativeWeight += spawn.rate;\r\n                if (randomWeight <= cumulativeWeight) {\r\n                    totalStrength += spawn.strength;\r\n\r\n                    if (totalStrength <= this.monsterSpawnInfo.randomSpawnInfo.maxTotalStrength) {\r\n                        encounterHrids.push({ 'hrid': spawn.combatMonsterHrid, 'difficultyTier': spawn.difficultyTier});\r\n\r\n                    } else {\r\n                        break outer;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        this.encountersKilled++;\r\n        return encounterHrids.map((hrid) => new Monster(hrid.hrid, hrid.difficultyTier + this.difficultyTier, this.mazeDifficulty, this.isMaze));\r\n    }\r\n\r\n    failWave() {\r\n        this.dungeonsFailed++;\r\n        this.encountersKilled = 1;\r\n    }\r\n\r\n    getNextWave() {\r\n        if (this.encountersKilled > this.dungeonSpawnInfo.maxWaves) {\r\n            this.dungeonsCompleted++;\r\n            this.encountersKilled = 1;\r\n        }\r\n        // console.log(\"Wave #\" + this.encountersKilled);\r\n        if (this.dungeonSpawnInfo.fixedSpawnsMap.hasOwnProperty(this.encountersKilled.toString())) {\r\n            let currentMonsters = this.dungeonSpawnInfo.fixedSpawnsMap[(this.encountersKilled).toString()];\r\n            this.encountersKilled++;\r\n            return currentMonsters.map((monster) => new Monster(monster.combatMonsterHrid, monster.difficultyTier + this.difficultyTier, this.mazeDifficulty, this.isMaze));\r\n        } else {\r\n            let monsterSpawns = {};\r\n            const waveKeys = Object.keys(this.dungeonSpawnInfo.randomSpawnInfoMap).map(Number).sort((a, b) => a - b);\r\n            if (this.encountersKilled > waveKeys[waveKeys.length - 1]) {\r\n                monsterSpawns = this.dungeonSpawnInfo.randomSpawnInfoMap[waveKeys[waveKeys.length - 1]];\r\n            } else {\r\n                for (let i = 0; i < waveKeys.length - 1; i++) {\r\n                    if (this.encountersKilled >= waveKeys[i] && this.encountersKilled <= waveKeys[i + 1]) {\r\n                        monsterSpawns = this.dungeonSpawnInfo.randomSpawnInfoMap[waveKeys[i]];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            let totalWeight = monsterSpawns.spawns.reduce((prev, cur) => prev + cur.rate, 0);\r\n\r\n            let encounterHrids = [];\r\n            let totalStrength = 0;\r\n\r\n            outer: for (let i = 0; i < monsterSpawns.maxSpawnCount; i++) {\r\n                let randomWeight = totalWeight * Math.random();\r\n                let cumulativeWeight = 0;\r\n\r\n                for (const spawn of monsterSpawns.spawns) {\r\n                    cumulativeWeight += spawn.rate;\r\n                    if (randomWeight <= cumulativeWeight) {\r\n                        totalStrength += spawn.strength;\r\n\r\n                        if (totalStrength <= monsterSpawns.maxTotalStrength) {\r\n                            encounterHrids.push({ 'hrid': spawn.combatMonsterHrid, 'difficultyTier': spawn.difficultyTier});\r\n\r\n                        } else {\r\n                            break outer;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            this.encountersKilled++;\r\n            return encounterHrids.map((hrid) => new Monster(hrid.hrid, hrid.difficultyTier + this.difficultyTier, this.mazeDifficulty, this.isMaze));\r\n        }\r\n    }\r\n}\r\n\r\nexport default Zone;\r\n","import CombatSimulator from \"./combatsimulator/combatSimulator\";\r\nimport Player from \"./combatsimulator/player\";\r\nimport Zone from \"./combatsimulator/zone\";\r\n\r\n\r\nonmessage = async function (event) {\r\n    switch (event.data.type) {\r\n        case \"start_simulation\":\r\n            let extraBuffs = [];\r\n            if (event.data.extra.mooPass) {\r\n                const mooPassBuff = {\r\n                    \"uniqueHrid\": \"/buff_uniques/experience_moo_pass_buff\",\r\n                    \"typeHrid\": \"/buff_types/wisdom\",\r\n                    \"ratioBoost\": 0,\r\n                    \"ratioBoostLevelBonus\": 0,\r\n                    \"flatBoost\": 0.05,\r\n                    \"flatBoostLevelBonus\": 0,\r\n                    \"startTime\": \"0001-01-01T00:00:00Z\",\r\n                    \"duration\": 0\r\n                };\r\n                extraBuffs.push(mooPassBuff);\r\n            }\r\n            if (event.data.extra.comExp > 0) {\r\n                const comExpBuff = {\r\n                    \"uniqueHrid\": \"/buff_uniques/experience_community_buff\",\r\n                    \"typeHrid\": \"/buff_types/wisdom\",\r\n                    \"ratioBoost\": 0,\r\n                    \"ratioBoostLevelBonus\": 0,\r\n                    \"flatBoost\": 0.005 * (event.data.extra.comExp - 1) + 0.2,\r\n                    \"flatBoostLevelBonus\": 0,\r\n                    \"startTime\": \"0001-01-01T00:00:00Z\",\r\n                    \"duration\": 0\r\n                };\r\n                extraBuffs.push(comExpBuff);\r\n            }\r\n            if (event.data.extra.comDrop > 0) {\r\n                const comDropBuff = {\r\n                    \"uniqueHrid\": \"/buff_uniques/combat_community_buff\",\r\n                    \"typeHrid\": \"/buff_types/combat_drop_quantity\",\r\n                    \"ratioBoost\": 0,\r\n                    \"ratioBoostLevelBonus\": 0,\r\n                    \"flatBoost\": 0.005 * (event.data.extra.comDrop - 1) + 0.2,\r\n                    \"flatBoostLevelBonus\": 0,\r\n                    \"startTime\": \"0001-01-01T00:00:00Z\",\r\n                    \"duration\": 0\r\n                };\r\n                extraBuffs.push(comDropBuff);\r\n            }\r\n\r\n            let playersData = event.data.players;\r\n            let players = [];\r\n            let zone = new Zone(event.data.zone.zoneHrid, event.data.zone.difficultyTier, event.data.zone?.mazeDifficulty);\r\n            for (let i = 0; i < playersData.length; i++) {\r\n                let currentPlayer = Player.createFromDTO(structuredClone(playersData[i]));\r\n                currentPlayer.zoneBuffs = zone.buffs;\r\n                currentPlayer.extraBuffs = extraBuffs;\r\n                // propagate maze flag to player so CombatUnit can apply maze-specific bonuses\r\n                currentPlayer.isMaze = zone.isMaze || false;\r\n                players.push(currentPlayer);\r\n            }\r\n            let simulationTimeLimit = event.data.simulationTimeLimit;\r\n            let enableHpMpVisualization = event.data.extra.enableHpMpVisualization || false;\r\n            let combatSimulator = new CombatSimulator(players, zone, { enableHpMpVisualization });\r\n            combatSimulator.addEventListener(\"progress\", (event) => {\r\n                this.postMessage({ \r\n                    type: \"simulation_progress\", \r\n                    progress: event.detail.progress, \r\n                    zone: event.detail.zone, \r\n                    difficultyTier: event.detail.difficultyTier,\r\n                    timeSeriesData: event.detail.timeSeriesData\r\n                });\r\n            });\r\n\r\n            try {\r\n                let simResult = await combatSimulator.simulate(simulationTimeLimit);\r\n                this.postMessage({ type: \"simulation_result\", simResult: simResult });\r\n            } catch (e) {\r\n                console.log(e);\r\n                this.postMessage({ type: \"simulation_error\", error: e });\r\n            }\r\n            break;\r\n    }\r\n};\r\n"],"names":[],"sourceRoot":""}